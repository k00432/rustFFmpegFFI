/* automatically generated by rust-bindgen */

#![allow(warnings)]
#[link(name="lib/avutil")]
extern "C" {}
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 0;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdFAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdMAX: &'static [u8; 4usize] = b"lld\0";
pub const PRIdPTR: &'static [u8; 4usize] = b"lld\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiFAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiMAX: &'static [u8; 4usize] = b"lli\0";
pub const PRIiPTR: &'static [u8; 4usize] = b"lli\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoFAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoMAX: &'static [u8; 4usize] = b"llo\0";
pub const PRIoPTR: &'static [u8; 4usize] = b"llo\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuFAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuMAX: &'static [u8; 4usize] = b"llu\0";
pub const PRIuPTR: &'static [u8; 4usize] = b"llu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxFAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxMAX: &'static [u8; 4usize] = b"llx\0";
pub const PRIxPTR: &'static [u8; 4usize] = b"llx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXFAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXMAX: &'static [u8; 4usize] = b"llX\0";
pub const PRIXPTR: &'static [u8; 4usize] = b"llX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdMAX: &'static [u8; 4usize] = b"lld\0";
pub const SCNdPTR: &'static [u8; 4usize] = b"lld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiMAX: &'static [u8; 4usize] = b"lli\0";
pub const SCNiPTR: &'static [u8; 4usize] = b"lli\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoMAX: &'static [u8; 4usize] = b"llo\0";
pub const SCNoPTR: &'static [u8; 4usize] = b"llo\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuMAX: &'static [u8; 4usize] = b"llu\0";
pub const SCNuPTR: &'static [u8; 4usize] = b"llu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxMAX: &'static [u8; 4usize] = b"llx\0";
pub const SCNxPTR: &'static [u8; 4usize] = b"llx\0";
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &'static [u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 56;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 23;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 101;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_E: f64 = 2.718281828459045;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const __GNUC_VA_LIST: u32 = 1;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;

extern "C" {
    /// Return the LIBAVUTIL_VERSION_INT constant.
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return an informative version string. This usually is the actual release
    /// version number or a git commit description. This string has no fixed format
    /// and can change any time. It should never be parsed by code.
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the libavutil build-time configuration.
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the libavutil license.
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
///< Usually treated as AVMEDIA_TYPE_DATA
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
///< Opaque data information usually continuous
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
///< Opaque data information usually sparse
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
/// @addtogroup lavu_media Media Type
/// @brief Media Type
pub type AVMediaType = i32;
extern "C" {
    /// Return a string describing the media_type enum, NULL if media_type
    /// is unknown.
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
///< Undefined
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
///< Intra
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
///< Predicted
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
///< Bi-dir predicted
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
///< S(GMC)-VOP MPEG-4
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
///< Switching Intra
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
///< Switching Predicted
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
///< BI type
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
/// @}
/// @}
/// @defgroup lavu_picture Image related
///
/// AVPicture types, pixel formats and basic image planes manipulation.
///
/// @{
pub type AVPictureType = i32;
extern "C" {
    /// Return a single letter to describe the given picture type
    /// pict_type.
    ///
    /// @param[in] pict_type the picture type @return a single character
    /// representing the picture type, '?' if pict_type is unknown
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout__Lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_Lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type imaxdiv_t = _Lldiv_t;
extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout__exception() {
    assert_eq!(
        ::std::mem::size_of::<_exception>(),
        40usize,
        concat!("Size of: ", stringify!(_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(_exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(retval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__complex() {
    assert_eq!(
        ::std::mem::size_of::<_complex>(),
        16usize,
        concat!("Size of: ", stringify!(_complex))
    );
    assert_eq!(
        ::std::mem::align_of::<_complex>(),
        8usize,
        concat!("Alignment of ", stringify!(_complex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(y)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "\u{1}_HUGE"]
    pub static _HUGE: f64;
}
extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__double_val() {
    assert_eq!(
        ::std::mem::size_of::<_double_val>(),
        8usize,
        concat!("Size of: ", stringify!(_double_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_double_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_double_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__float_val() {
    assert_eq!(
        ::std::mem::size_of::<_float_val>(),
        4usize,
        concat!("Size of: ", stringify!(_float_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_val>(),
        4usize,
        concat!("Alignment of ", stringify!(_float_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__ldouble_val() {
    assert_eq!(
        ::std::mem::size_of::<_ldouble_val>(),
        8usize,
        concat!("Size of: ", stringify!(_ldouble_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldouble_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_ldouble_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__float_const() {
    assert_eq!(
        ::std::mem::size_of::<_float_const>(),
        8usize,
        concat!("Size of: ", stringify!(_float_const))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_const>(),
        8usize,
        concat!("Alignment of ", stringify!(_float_const))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Long_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Long_double)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Denorm_C"]
    pub static _Denorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Inf_C"]
    pub static _Inf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Nan_C"]
    pub static _Nan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Snan_C"]
    pub static _Snan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Hugeval_C"]
    pub static _Hugeval_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FDenorm_C"]
    pub static _FDenorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FInf_C"]
    pub static _FInf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FNan_C"]
    pub static _FNan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FSnan_C"]
    pub static _FSnan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LDenorm_C"]
    pub static _LDenorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LInf_C"]
    pub static _LInf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LNan_C"]
    pub static _LNan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LSnan_C"]
    pub static _LSnan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Eps_C"]
    pub static _Eps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Rteps_C"]
    pub static _Rteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FEps_C"]
    pub static _FEps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FRteps_C"]
    pub static _FRteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LEps_C"]
    pub static _LEps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LRteps_C"]
    pub static _LRteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Zero_C"]
    pub static _Zero_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_Xbig_C"]
    pub static _Xbig_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_FZero_C"]
    pub static _FZero_C: f32;
}
extern "C" {
    #[link_name = "\u{1}_FXbig_C"]
    pub static _FXbig_C: f32;
}
extern "C" {
    #[link_name = "\u{1}_LZero_C"]
    pub static _LZero_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_LXbig_C"]
    pub static _LXbig_C: f64;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erf(_X: f64) -> f64;
}
extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
extern "C" {
    pub fn log2(_X: f64) -> f64;
}
extern "C" {
    pub fn logb(_X: f64) -> f64;
}
extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(_X: f64) -> f64;
}
extern "C" {
    pub fn round(_X: f64) -> f64;
}
extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn erff(_X: f32) -> f32;
}
extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
extern "C" {
    pub fn logf(_X: f32) -> f32;
}
extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}HUGE"]
    pub static mut HUGE: f64;
}
extern "C" {
    pub fn j0(_X: f64) -> f64;
}
extern "C" {
    pub fn j1(_X: f64) -> f64;
}
extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn y0(_X: f64) -> f64;
}
extern "C" {
    pub fn y1(_X: f64) -> f64;
}
extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_iobuf>()))._Placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDOUBLE>())).ld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_DOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_FLOAT>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LONGDOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDBL12>())).ld12 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const wchar_t) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Put a description of the AVERROR code errnum in errbuf.
    /// In case of failure the global variable errno is set to indicate the
    /// error. Even in case of failure av_strerror() will print a generic
    /// error message indicating the errnum provided to errbuf.
    ///
    /// @param errnum      error code to describe
    /// @param errbuf      buffer to which description is written
    /// @param errbuf_size the size in bytes of errbuf
    /// @return 0 on success, a negative value if a description for errnum
    /// cannot be found
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}

extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU).
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    ///         be allocated
    /// @see av_mallocz()
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU) and zero all the bytes of the
    /// block.
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if it cannot be allocated
    /// @see av_malloc()
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a memory block for an array with av_malloc().
    ///
    /// The allocated memory will have size `size * nmemb` bytes.
    ///
    /// @param nmemb Number of element
    /// @param size  Size of a single element
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    ///         be allocated
    /// @see av_malloc()
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a memory block for an array with av_mallocz().
    ///
    /// The allocated memory will have size `size * nmemb` bytes.
    ///
    /// @param nmemb Number of elements
    /// @param size  Size of the single element
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    ///         be allocated
    ///
    /// @see av_mallocz()
    /// @see av_malloc_array()
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Non-inlined equivalent of av_mallocz_array().
    ///
    /// Created for symmetry with the calloc() C function.
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param ptr  Pointer to a memory block already allocated with
    ///             av_realloc() or `NULL`
    /// @param size Size in bytes of the memory block to be allocated or
    ///             reallocated
    ///
    /// @return Pointer to a newly-reallocated block or `NULL` if the block
    ///         cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
    ///          correctly aligned.
    /// @see av_fast_realloc()
    /// @see av_reallocp()
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory through a pointer to a
    /// pointer.
    ///
    /// If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
    ///                     with av_realloc(), or a pointer to `NULL`. The pointer
    ///                     is updated on success, or freed on failure.
    /// @param[in]     size Size in bytes for the memory block to be allocated or
    ///                     reallocated
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    ///          correctly aligned.
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// This function does the same thing as av_realloc(), except:
    /// - It takes two size arguments and allocates `nelem * elsize` bytes,
    ///   after checking the result of the multiplication for integer overflow.
    /// - It frees the input block in case of failure, thus avoiding the memory
    ///   leak with the classic
    ///   @code{.c}
    ///   buf = realloc(buf);
    ///   if (!buf)
    ///       return -1;
    ///   @endcode
    ///   pattern.
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array.
    ///
    /// If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
    /// `nmemb` is zero, free the memory block pointed to by `ptr`.
    ///
    /// @param ptr   Pointer to a memory block already allocated with
    ///              av_realloc() or `NULL`
    /// @param nmemb Number of elements in the array
    /// @param size  Size of the single element of the array
    ///
    /// @return Pointer to a newly-reallocated block or NULL if the block
    ///         cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    ///          correctly aligned.
    /// @see av_reallocp_array()
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array through a pointer to a pointer.
    ///
    /// If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
    /// zero, free the memory block pointed to by `*ptr`.
    ///
    /// @param[in,out] ptr   Pointer to a pointer to a memory block already
    ///                      allocated with av_realloc(), or a pointer to `NULL`.
    ///                      The pointer is updated on success, or freed on failure.
    /// @param[in]     nmemb Number of elements
    /// @param[in]     size  Size of the single element
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    ///          correctly aligned.
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reallocate the given buffer if it is not large enough, otherwise do nothing.
    ///
    /// If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
    ///
    /// If the given buffer is not large enough, and reallocation fails, `NULL` is
    /// returned and `*size` is set to 0, but the original buffer is not changed or
    /// freed.
    ///
    /// A typical use pattern follows:
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
    /// if (!new_buf) {
    ///     // Allocation failed; clean up original buffer
    ///     av_freep(&buf);
    ///     return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Already allocated buffer, or `NULL`
    /// @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is
    ///                         updated to the new allocated size, in particular 0
    ///                         in case of failure.
    /// @param[in]     min_size Desired minimal size of buffer `ptr`
    /// @return `ptr` if the buffer is large enough, a pointer to newly reallocated
    ///         buffer if the buffer was not large enough, or `NULL` in case of
    ///         error
    /// @see av_realloc()
    /// @see av_fast_malloc()
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a buffer, reusing the given one if large enough.
    ///
    /// Contrary to av_fast_realloc(), the current buffer contents might not be
    /// preserved and on error the old buffer is freed, thus no special handling to
    /// avoid memleaks is necessary.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// av_fast_malloc(&buf, &current_size, size_needed);
    /// if (!buf) {
    ///     // Allocation failed; buf already freed
    ///     return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    ///                         `*ptr` will be overwritten with pointer to new
    ///                         buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
    ///                         updated to the new allocated size, in particular 0
    ///                         in case of failure.
    /// @param[in]     min_size Desired minimal size of buffer `*ptr`
    /// @see av_realloc()
    /// @see av_fast_mallocz()
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Allocate and clear a buffer, reusing the given one if large enough.
    ///
    /// Like av_fast_malloc(), but all newly allocated space is initially cleared.
    /// Reused buffer is not cleared.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    ///                         `*ptr` will be overwritten with pointer to new
    ///                         buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
    ///                         updated to the new allocated size, in particular 0
    ///                         in case of failure.
    /// @param[in]     min_size Desired minimal size of buffer `*ptr`
    /// @see av_fast_malloc()
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family.
    ///
    /// @param ptr Pointer to the memory block which should be freed.
    ///
    /// @note `ptr = NULL` is explicitly allowed.
    /// @note It is recommended that you use av_freep() instead, to prevent leaving
    ///       behind dangling pointers.
    /// @see av_freep()
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family, and set the pointer pointing to it to `NULL`.
    ///
    /// @code{.c}
    /// uint8_t *buf = av_malloc(16);
    /// av_free(buf);
    /// // buf now contains a dangling pointer to freed memory, and accidental
    /// // dereference of buf will result in a use-after-free, which may be a
    /// // security risk.
    ///
    /// uint8_t *buf = av_malloc(16);
    /// av_freep(&buf);
    /// // buf is now NULL, and accidental dereference will only result in a
    /// // NULL-pointer dereference.
    /// @endcode
    ///
    /// @param ptr Pointer to the pointer to the memory block which should be freed
    /// @note `*ptr = NULL` is safe and leads to no action.
    /// @see av_free()
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Duplicate a string.
    ///
    /// @param s String to be duplicated
    /// @return Pointer to a newly-allocated string containing a
    ///         copy of `s` or `NULL` if the string cannot be allocated
    /// @see av_strndup()
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Duplicate a substring of a string.
    ///
    /// @param s   String to be duplicated
    /// @param len Maximum length of the resulting string (not counting the
    ///            terminating byte)
    /// @return Pointer to a newly-allocated string containing a
    ///         substring of `s` or `NULL` if the string cannot be allocated
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Duplicate a buffer with av_malloc().
    ///
    /// @param p    Buffer to be duplicated
    /// @param size Size in bytes of the buffer copied
    /// @return Pointer to a newly allocated buffer containing a
    ///         copy of `p` or `NULL` if the buffer cannot be allocated
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Overlapping memcpy() implementation.
    ///
    /// @param dst  Destination buffer
    /// @param back Number of bytes back to start copying (i.e. the initial size of
    ///             the overlapping window); must be > 0
    /// @param cnt  Number of bytes to copy; must be >= 0
    ///
    /// @note `cnt > back` is valid, this will copy the bytes we just copied,
    ///       thus creating a repeating pattern with a period length of `back`.
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    /// Add the pointer to an element to a dynamic array.
    ///
    /// The array to grow is supposed to be an array of pointers to
    /// structures, and the element to add must be a pointer to an already
    /// allocated structure.
    ///
    /// The array is reallocated when its size reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr Pointer to the array to grow
    /// @param[in,out] nb_ptr  Pointer to the number of elements in the array
    /// @param[in]     elem    Element to add
    /// @see av_dynarray_add_nofree(), av_dynarray2_add()
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Add an element to a dynamic array.
    ///
    /// Function has the same functionality as av_dynarray_add(),
    /// but it doesn't free memory on fails. It returns error code
    /// instead and leave current buffer untouched.
    ///
    /// @return >=0 on success, negative otherwise
    /// @see av_dynarray_add(), av_dynarray2_add()
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add an element of size `elem_size` to a dynamic array.
    ///
    /// The array is reallocated when its number of elements reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr   Pointer to the array to grow
    /// @param[in,out] nb_ptr    Pointer to the number of elements in the array
    /// @param[in]     elem_size Size in bytes of an element in the array
    /// @param[in]     elem_data Pointer to the data of the element to add. If
    ///                          `NULL`, the space of the newly added element is
    ///                          allocated but left uninitialized.
    ///
    /// @return Pointer to the data of the element to copy in the newly allocated
    ///         space
    /// @see av_dynarray_add(), av_dynarray_add_nofree()
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Set the maximum size that may be allocated in one block.
    ///
    /// The value specified with this function is effective for all libavutil's @ref
    /// lavu_mem_funcs "heap management functions."
    ///
    /// By default, the max value is defined as `INT_MAX`.
    ///
    /// @param max Value to be set as the new maximum size
    ///
    /// @warning Exercise extreme caution when using this function. Don't touch
    ///          this if you do not understand the full consequence of doing so.
    pub fn av_max_alloc(max: usize);
}
/// Rational number (pair of numerator and denominator).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    ///< Numerator
    pub num: ::std::os::raw::c_int,
    ///< Denominator
    pub den: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    assert_eq!(
        ::std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    /// Reduce a fraction.
    ///
    /// This is useful for framerate calculations.
    ///
    /// @param[out] dst_num Destination numerator
    /// @param[out] dst_den Destination denominator
    /// @param[in]      num Source numerator
    /// @param[in]      den Source denominator
    /// @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
    /// @return 1 if the operation is exact, 0 otherwise
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Multiply two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b*c
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Divide one rational by another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b/c
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Add two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b+c
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Subtract one rational from another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b-c
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Convert a double precision floating point number to a rational.
    ///
    /// In case of infinity, the returned value is expressed as `{1, 0}` or
    /// `{-1, 0}` depending on the sign.
    ///
    /// @param d   `double` to convert
    /// @param max Maximum allowed numerator and denominator
    /// @return `d` in AVRational form
    /// @see av_q2d()
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    /// Find which of the two rationals is closer to another rational.
    ///
    /// @param q     Rational to be compared against
    /// @param q1,q2 Rationals to be tested
    /// @return One of the following values:
    ///         - 1 if `q1` is nearer to `q` than `q2`
    ///         - -1 if `q2` is nearer to `q` than `q1`
    ///         - 0 if they have the same distance
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find the value in a list of rationals nearest a given reference rational.
    ///
    /// @param q      Reference rational
    /// @param q_list Array of rationals terminated by `{0, 0}`
    /// @return Index of the nearest value found in the array
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
    /// format.
    ///
    /// @param q Rational to be converted
    /// @return Equivalent floating-point value, expressed as an unsigned 32-bit
    ///         integer.
    /// @note The returned value is platform-indepedant.
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
///< Round toward zero.
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
///< Round away from zero.
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
///< Round toward -infinity.
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
///< Round toward +infinity.
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
///< Round to nearest and halfway cases away from zero.
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
/// Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
/// unchanged, avoiding special cases for #AV_NOPTS_VALUE.
///
/// Unlike other values of the enumeration AVRounding, this value is a
/// bitmask that must be used in conjunction with another value of the
/// enumeration through a bitwise OR, in order to set behavior for normal
/// cases.
///
/// @code{.c}
/// av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
/// // Rescaling 3:
/// //     Calculating 3 * 1 / 2
/// //     3 / 2 is rounded up to 2
/// //     => 2
///
/// av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
/// // Rescaling AV_NOPTS_VALUE:
/// //     AV_NOPTS_VALUE == INT64_MIN
/// //     AV_NOPTS_VALUE is passed through
/// //     => AV_NOPTS_VALUE
/// @endcode
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
/// Rounding methods.
pub type AVRounding = i32;
extern "C" {
    /// Compute the greatest common divisor of two integer operands.
    ///
    /// @param a,b Operands
    /// @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
    /// if a == 0 and b == 0, returns 0.
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with rounding to nearest.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow.
    ///
    /// This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow, and does not support different rounding methods.
    ///
    /// @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q()
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Compare two timestamps each in its own time base.
    ///
    /// @return One of the following values:
    ///         - -1 if `ts_a` is before `ts_b`
    ///         - 1 if `ts_a` is after `ts_b`
    ///         - 0 if they represent the same position
    ///
    /// @warning
    /// The result of the function is undefined if one of the timestamps is outside
    /// the `int64_t` range when represented in the other's timebase.
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Compare the remainders of two integer operands divided by a common divisor.
    ///
    /// In other words, compare the least significant `log2(mod)` bits of integers
    /// `a` and `b`.
    ///
    /// @code{.c}
    /// av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
    /// av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
    /// @endcode
    ///
    /// @param a,b Operands
    /// @param mod Divisor; must be a power of 2
    /// @return
    ///         - a negative value if `a % mod < b % mod`
    ///         - a positive value if `a % mod > b % mod`
    ///         - zero             if `a % mod == b % mod`
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    /// Rescale a timestamp while preserving known durations.
    ///
    /// This function is designed to be called per audio packet to scale the input
    /// timestamp to a different time base. Compared to a simple av_rescale_q()
    /// call, this function is robust against possible inconsistent frame durations.
    ///
    /// The `last` parameter is a state variable that must be preserved for all
    /// subsequent calls for the same stream. For the first call, `*last` should be
    /// initialized to #AV_NOPTS_VALUE.
    ///
    /// @param[in]     in_tb    Input time base
    /// @param[in]     in_ts    Input timestamp
    /// @param[in]     fs_tb    Duration time base; typically this is finer-grained
    ///                         (greater) than `in_tb` and `out_tb`
    /// @param[in]     duration Duration till the next call to this function (i.e.
    ///                         duration of the current packet/frame)
    /// @param[in,out] last     Pointer to a timestamp expressed in terms of
    ///                         `fs_tb`, acting as a state variable
    /// @param[in]     out_tb   Output timebase
    /// @return        Timestamp expressed in terms of `out_tb`
    ///
    /// @note In the context of this function, "duration" is in term of samples, not
    ///       seconds.
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    /// Add a value to a timestamp.
    ///
    /// This function guarantees that when the same value is repeatly added that
    /// no accumulation of rounding errors occurs.
    ///
    /// @param[in] ts     Input timestamp
    /// @param[in] ts_tb  Input timestamp time base
    /// @param[in] inc    Value to be added
    /// @param[in] inc_tb Time base of `inc`
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub type __gnuc_va_list = __builtin_va_list;
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
///< not part of ABI/API
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
/// Describe the class of an AVClass context structure. That is an
/// arbitrary struct of which the first field is a pointer to an
/// AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    /// The name of the class; usually it is the same name as the
    /// context structure type to which the AVClass is associated.
    pub class_name: *const ::std::os::raw::c_char,
    /// A pointer to a function which returns the name of a context
    /// instance ctx associated with the class.
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    /// a pointer to the first option specified in the class if any or NULL
    ///
    /// @see av_set_default_options()
    pub option: *mut AVOption,
    /// LIBAVUTIL_VERSION with which this structure was created.
    /// This is used to allow fields to be added without requiring major
    /// version bumps everywhere.
    pub version: ::std::os::raw::c_int,
    /// Offset in the structure where log_level_offset is stored.
    /// 0 means there is no such variable
    pub log_level_offset_offset: ::std::os::raw::c_int,
    /// Offset in the structure where a pointer to the parent context for
    /// logging is stored. For example a decoder could pass its AVCodecContext
    /// to eval as such a parent context, which an av_log() implementation
    /// could then leverage to display the parent context.
    /// The offset can be NULL.
    pub parent_log_context_offset: ::std::os::raw::c_int,
    /// Return next AVOptions-enabled child or NULL
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut ::std::os::raw::c_void, prev: *mut ::std::os::raw::c_void)
            -> *mut ::std::os::raw::c_void,
    >,
    /// Return an AVClass corresponding to the next potential
    /// AVOptions-enabled child.
    ///
    /// The difference between child_next and this is that
    /// child_next iterates over _already existing_ objects, while
    /// child_class_next iterates over _all possible_ children.
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    /// Category used for visualization (like color)
    /// This is only set if the category is equal for all objects using this class.
    /// available since version (51 << 16 | 56 << 8 | 100)
    pub category: AVClassCategory,
    /// Callback to return the category.
    /// available since version (51 << 16 | 59 << 8 | 100)
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    /// Callback to return the supported/allowed ranges.
    /// available since version (52.12)
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(
        ::std::mem::size_of::<AVClass>(),
        80usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        ::std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).class_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).item_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).category as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).get_category as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    ///        pointer to an AVClass struct or NULL if general log.
    /// @param level The importance level of the message expressed using a @ref
    ///        lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    ///        subsequent arguments are converted to output.
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    ///        pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    ///        lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    ///        subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    /// Get the current log level
    ///
    /// @see lavu_log_constants
    ///
    /// @return Current log level
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level
    ///
    /// @see lavu_log_constants
    ///
    /// @param level Logging level
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    /// Set the logging callback
    ///
    /// @note The callback must be thread safe, even if the application does not use
    ///       threads itself as some codecs are multithreaded.
    ///
    /// @see av_log_default_callback
    ///
    /// @param callback A logging function with a compatible signature.
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    /// Default logging callback
    ///
    /// It prints the message to stderr, optionally colorizing it.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    ///        pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    ///        lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    ///        subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    /// Return the context name
    ///
    /// @param  ctx The AVClass context
    ///
    /// @return The AVClass class_name
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line
    /// @param line_size     size of the buffer
    /// @param print_prefix  used to store whether the prefix must be printed;
    ///                      must point to a persistent integer initially set to 1
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line;
    ///                      may be NULL if line_size is 0
    /// @param line_size     size of the buffer; at most line_size-1 characters will
    ///                      be written to the buffer, plus one null terminator
    /// @param print_prefix  used to store whether the prefix must be printed;
    ///                      must point to a persistent integer initially set to 1
    /// @return Returns a negative value if an error occurred, otherwise returns
    ///         the number of characters that would have been written for a
    ///         sufficiently large buffer, not including the terminating null
    ///         character. If the return value is not less than line_size, it means
    ///         that the log message was truncated to fit the buffer.
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
///< packed RGB 8:8:8, 24bpp, RGBRGB...
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
///< packed RGB 8:8:8, 24bpp, BGRBGR...
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
///<        Y        ,  8bpp
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
///<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
///<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
///< 8 bits with AV_PIX_FMT_RGB32 palette
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
///< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
///< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
///< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
///< as above, but U and V bytes are swapped
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
///<        Y        , 16bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
///<        Y        , 16bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
///< HW decoding through VA API, Picture.data[3] contains a VASurfaceID
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
///@}
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
///< 8 bits gray, 8 bits alpha
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 58;
///< alias for AV_PIX_FMT_YA8
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 58;
///< alias for AV_PIX_FMT_YA8
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
///< planar GBR 4:4:4 24bpp
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
///< planar GBR 4:4:4 27bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
///< planar GBR 4:4:4 27bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
///< planar GBR 4:4:4 30bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
///< planar GBR 4:4:4 30bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
///< planar GBR 4:4:4 48bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
///< planar GBR 4:4:4 48bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
///< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 103;
///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
///< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
///< 16 bits gray, 16 bits alpha (big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
///< 16 bits gray, 16 bits alpha (little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
///< planar GBRA 4:4:4:4 32bpp
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
///< planar GBRA 4:4:4:4 64bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
///< planar GBRA 4:4:4:4 64bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
///  HW acceleration through QSV, data[3] contains a pointer to the
///  mfxFrameSurface1 structure.
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 116;
/// HW acceleration though MMAL, data[3] contains a pointer to the
/// MMAL_BUFFER_HEADER_T structure.
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 117;
///< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
/// HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
/// exactly as for system memory frames.
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 119;
///< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 120;
///< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 121;
///< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 122;
///< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 123;
///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
///< planar GBR 4:4:4 36bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
///< planar GBR 4:4:4 36bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
///< planar GBR 4:4:4 42bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
///< planar GBR 4:4:4 42bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
///< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
///< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
///< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
///< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
///< XVideo Motion Acceleration via common packet passing
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 153;
///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
///< hardware decoding through Videotoolbox
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 161;
///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 162;
///< planar GBR 4:4:4:4 48bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
///< planar GBR 4:4:4:4 48bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
///< planar GBR 4:4:4:4 40bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
///< planar GBR 4:4:4:4 40bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
///< hardware decoding through MediaCodec
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
///<        Y        , 12bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
///<        Y        , 12bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
///<        Y        , 10bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
///<        Y        , 10bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
///< like NV12, with 16bpp per component, little-endian
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 172;
///< like NV12, with 16bpp per component, big-endian
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 173;
/// Hardware surfaces for Direct3D11.
///
/// This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
/// hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
///
/// data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
/// texture array index of the frame as intptr_t if the ID3D11Texture2D is
/// an array texture (or always 0 if it's a normal texture).
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 174;
///<        Y        , 9bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
///<        Y        , 9bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
/// DRM-managed buffers exposed through PRIME buffer sharing.
///
/// data[0] points to an AVDRMFrameDescriptor.
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
/// Hardware surfaces for OpenCL.
///
/// data[i] contain 2D image objects (typed in C as cl_mem, used
/// in OpenCL as image2d_t) for each plane of the surface.
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
///<        Y        , 14bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 183;
///<        Y        , 14bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 184;
///< IEEE-754 single precision Y, 32bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 185;
///< IEEE-754 single precision Y, 32bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 186;
///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 187;
/// Pixel format.
///
/// @note
/// AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
/// color is put together as:
///  (A << 24) | (R << 16) | (G << 8) | B
/// This is stored as BGRA on little-endian CPU architectures and ARGB on
/// big-endian CPUs.
///
/// @note
/// If the resolution is not a multiple of the chroma subsampling factor
/// then the chroma plane resolution must be rounded up.
///
/// @par
/// When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
/// image data is stored in AVFrame.data[0]. The palette is transported in
/// AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
/// formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
/// also endian-specific). Note also that the individual RGB32 palette
/// components stored in AVFrame.data[1] should be in the range 0..255.
/// This is important as many custom PAL8 video codecs that were designed
/// to run on the IBM VGA graphics adapter use 6-bit palette components.
///
/// @par
/// For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
/// for pal8. This palette is filled in automatically by the function
/// allocating the picture.
pub type AVPixelFormat = i32;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
///< functionally identical to above
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
///< colour filters using Illuminant C
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
///< ITU-R BT2020
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
///< SMPTE ST 428-1 (CIE 1931 XYZ)
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
///< SMPTE ST 431-2 (2011) / DCI P3
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
///< JEDEC P22 phosphors
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
///< Not part of ABI
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
/// Chromaticity coordinates of the source primaries.
/// These values match the ones defined by ISO/IEC 23001-8_2013  7.1.
pub type AVColorPrimaries = i32;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
///< also ITU-R BT1361
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
///< also ITU-R BT470BG
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
///< "Linear transfer characteristics"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
///< "Logarithmic transfer characteristic (100:1 range)"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
///< "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
///< IEC 61966-2-4
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
///< ITU-R BT1361 Extended Colour Gamut
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
///< IEC 61966-2-1 (sRGB or sYCC)
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
///< ITU-R BT2020 for 10-bit system
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
///< ITU-R BT2020 for 12-bit system
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
///< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
///< SMPTE ST 428-1
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
///< ARIB STD-B67, known as "Hybrid log-gamma"
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
///< Not part of ABI
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
/// Color Transfer Characteristic.
/// These values match the ones defined by ISO/IEC 23001-8_2013  7.2.
pub type AVColorTransferCharacteristic = i32;
///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
///< functionally identical to above
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
///< ITU-R BT2020 non-constant luminance system
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
///< ITU-R BT2020 constant luminance system
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
///< SMPTE 2085, Y'D'zD'x
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
///< Chromaticity-derived non-constant luminance system
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
///< Chromaticity-derived constant luminance system
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
///< ITU-R BT.2100-0, ICtCp
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
///< Not part of ABI
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
/// YUV colorspace type.
/// These values match the ones defined by ISO/IEC 23001-8_2013  7.3.
pub type AVColorSpace = i32;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
///< the normal 219*2^(n-8) "MPEG" YUV ranges
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
///< the normal     2^n-1   "JPEG" YUV ranges
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
///< Not part of ABI
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
/// MPEG vs JPEG YUV range.
pub type AVColorRange = i32;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
///< MPEG-2/4 4:2:0, H.264 default for 4:2:0
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
///< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
///< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
///< Not part of ABI
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
/// Location of chroma samples.
///
/// Illustration showing the location of the first (top left) chroma sample of the
/// image, the left shows only luma, the right
/// shows the location of the chroma sample, the 2 could be imagined to overlay
/// each other but are drawn separately due to limitations of ASCII
///
///                1st 2nd       1st 2nd horizontal luma sample positions
///                 v   v         v   v
///                 ______        ______
///1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
///                |             |1 2           1-6 are possible chroma positions
///2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
pub type AVChromaLocation = i32;
extern "C" {
    /// Compute the length of an integer list.
    ///
    /// @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
    /// @param term    list terminator (usually 0 or -1)
    /// @param list    pointer to the list
    /// @return  length of the list, in elements, not counting the terminator
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Open a file using a UTF-8 filename.
    /// The API of this function matches POSIX fopen(), errors are returned through
    /// errno.
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    /// Return the fractional representation of the internal time base.
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    /// Fill the provided buffer with a string containing a FourCC (four-character
    /// code) representation.
    ///
    /// @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
    /// @param fourcc the fourcc to represent
    /// @return the buffer in input
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
/// a pointer to the first option specified in the class if any or NULL
///
/// @see av_set_default_options()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOption {
    pub _address: u8,
}
