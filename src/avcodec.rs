/* automatically generated by rust-bindgen */
#![allow(warnings)]
#[link(name="lib/avcodec")]
extern "C" {}
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 0;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdFAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdMAX: &'static [u8; 4usize] = b"lld\0";
pub const PRIdPTR: &'static [u8; 4usize] = b"lld\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiFAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiMAX: &'static [u8; 4usize] = b"lli\0";
pub const PRIiPTR: &'static [u8; 4usize] = b"lli\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoFAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoMAX: &'static [u8; 4usize] = b"llo\0";
pub const PRIoPTR: &'static [u8; 4usize] = b"llo\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuFAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuMAX: &'static [u8; 4usize] = b"llu\0";
pub const PRIuPTR: &'static [u8; 4usize] = b"llu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxFAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxMAX: &'static [u8; 4usize] = b"llx\0";
pub const PRIxPTR: &'static [u8; 4usize] = b"llx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXFAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXMAX: &'static [u8; 4usize] = b"llX\0";
pub const PRIXPTR: &'static [u8; 4usize] = b"llX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdMAX: &'static [u8; 4usize] = b"lld\0";
pub const SCNdPTR: &'static [u8; 4usize] = b"lld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiMAX: &'static [u8; 4usize] = b"lli\0";
pub const SCNiPTR: &'static [u8; 4usize] = b"lli\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoMAX: &'static [u8; 4usize] = b"llo\0";
pub const SCNoPTR: &'static [u8; 4usize] = b"llo\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuMAX: &'static [u8; 4usize] = b"llu\0";
pub const SCNuPTR: &'static [u8; 4usize] = b"llu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxMAX: &'static [u8; 4usize] = b"llx\0";
pub const SCNxPTR: &'static [u8; 4usize] = b"llx\0";
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &'static [u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 56;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 23;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 101;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_E: f64 = 2.718281828459045;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const __GNUC_VA_LIST: u32 = 1;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: u32 = 1;
pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
pub const AV_CPU_FLAG_MMX2: u32 = 2;
pub const AV_CPU_FLAG_3DNOW: u32 = 4;
pub const AV_CPU_FLAG_SSE: u32 = 8;
pub const AV_CPU_FLAG_SSE2: u32 = 16;
pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const AV_CPU_FLAG_SSE3: u32 = 64;
pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
pub const AV_CPU_FLAG_SSSE3: u32 = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: u32 = 67108864;
pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
pub const AV_CPU_FLAG_SSE4: u32 = 256;
pub const AV_CPU_FLAG_SSE42: u32 = 512;
pub const AV_CPU_FLAG_AESNI: u32 = 524288;
pub const AV_CPU_FLAG_AVX: u32 = 16384;
pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
pub const AV_CPU_FLAG_XOP: u32 = 1024;
pub const AV_CPU_FLAG_FMA4: u32 = 2048;
pub const AV_CPU_FLAG_CMOV: u32 = 4096;
pub const AV_CPU_FLAG_AVX2: u32 = 32768;
pub const AV_CPU_FLAG_FMA3: u32 = 65536;
pub const AV_CPU_FLAG_BMI1: u32 = 131072;
pub const AV_CPU_FLAG_BMI2: u32 = 262144;
pub const AV_CPU_FLAG_AVX512: u32 = 1048576;
pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
pub const AV_CPU_FLAG_VSX: u32 = 2;
pub const AV_CPU_FLAG_POWER8: u32 = 4;
pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
pub const AV_CPU_FLAG_ARMV6: u32 = 2;
pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
pub const AV_CPU_FLAG_VFP: u32 = 8;
pub const AV_CPU_FLAG_VFPV3: u32 = 16;
pub const AV_CPU_FLAG_NEON: u32 = 32;
pub const AV_CPU_FLAG_ARMV8: u32 = 64;
pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
pub const AV_CPU_FLAG_SETEND: u32 = 65536;
pub const AV_CH_FRONT_LEFT: u32 = 1;
pub const AV_CH_FRONT_RIGHT: u32 = 2;
pub const AV_CH_FRONT_CENTER: u32 = 4;
pub const AV_CH_LOW_FREQUENCY: u32 = 8;
pub const AV_CH_BACK_LEFT: u32 = 16;
pub const AV_CH_BACK_RIGHT: u32 = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: u32 = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: u32 = 128;
pub const AV_CH_BACK_CENTER: u32 = 256;
pub const AV_CH_SIDE_LEFT: u32 = 512;
pub const AV_CH_SIDE_RIGHT: u32 = 1024;
pub const AV_CH_TOP_CENTER: u32 = 2048;
pub const AV_CH_TOP_FRONT_LEFT: u32 = 4096;
pub const AV_CH_TOP_FRONT_CENTER: u32 = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: u32 = 16384;
pub const AV_CH_TOP_BACK_LEFT: u32 = 32768;
pub const AV_CH_TOP_BACK_CENTER: u32 = 65536;
pub const AV_CH_TOP_BACK_RIGHT: u32 = 131072;
pub const AV_CH_STEREO_LEFT: u32 = 536870912;
pub const AV_CH_STEREO_RIGHT: u32 = 1073741824;
pub const AV_CH_WIDE_LEFT: u32 = 2147483648;
pub const AV_CH_WIDE_RIGHT: u64 = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: u64 = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: u64 = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: u64 = 34359738368;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_CH_LAYOUT_MONO: u32 = 4;
pub const AV_CH_LAYOUT_STEREO: u32 = 3;
pub const AV_CH_LAYOUT_2POINT1: u32 = 11;
pub const AV_CH_LAYOUT_2_1: u32 = 259;
pub const AV_CH_LAYOUT_SURROUND: u32 = 7;
pub const AV_CH_LAYOUT_3POINT1: u32 = 15;
pub const AV_CH_LAYOUT_4POINT0: u32 = 263;
pub const AV_CH_LAYOUT_4POINT1: u32 = 271;
pub const AV_CH_LAYOUT_2_2: u32 = 1539;
pub const AV_CH_LAYOUT_QUAD: u32 = 51;
pub const AV_CH_LAYOUT_5POINT0: u32 = 1543;
pub const AV_CH_LAYOUT_5POINT1: u32 = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: u32 = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: u32 = 63;
pub const AV_CH_LAYOUT_6POINT0: u32 = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: u32 = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: u32 = 311;
pub const AV_CH_LAYOUT_6POINT1: u32 = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: u32 = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: u32 = 1739;
pub const AV_CH_LAYOUT_7POINT0: u32 = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: u32 = 1735;
pub const AV_CH_LAYOUT_7POINT1: u32 = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: u32 = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: u32 = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: u32 = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: u64 = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: u32 = 1610612736;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 58;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 39;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 100;
pub const AV_CODEC_PROP_INTRA_ONLY: u32 = 1;
pub const AV_CODEC_PROP_LOSSY: u32 = 2;
pub const AV_CODEC_PROP_LOSSLESS: u32 = 4;
pub const AV_CODEC_PROP_REORDER: u32 = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: u32 = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: u32 = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: u32 = 64;
pub const AV_INPUT_BUFFER_MIN_SIZE: u32 = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: u32 = 1;
pub const AV_CODEC_FLAG_QSCALE: u32 = 2;
pub const AV_CODEC_FLAG_4MV: u32 = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const AV_CODEC_FLAG_QPEL: u32 = 16;
pub const AV_CODEC_FLAG_PASS1: u32 = 512;
pub const AV_CODEC_FLAG_PASS2: u32 = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const AV_CODEC_FLAG_GRAY: u32 = 8192;
pub const AV_CODEC_FLAG_PSNR: u32 = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: u32 = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: u32 = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: u32 = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: u32 = 1073741824;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const AV_CODEC_CAP_DR1: u32 = 2;
pub const AV_CODEC_CAP_TRUNCATED: u32 = 8;
pub const AV_CODEC_CAP_DELAY: u32 = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const AV_CODEC_CAP_SUBFRAMES: u32 = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const AV_CODEC_CAP_AUTO_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: u32 = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: u32 = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const AV_CODEC_CAP_HARDWARE: u32 = 262144;
pub const AV_CODEC_CAP_HYBRID: u32 = 524288;
pub const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE: u32 = 1048576;
pub const AV_GET_BUFFER_FLAG_REF: u32 = 1;
pub const AV_PKT_FLAG_KEY: u32 = 1;
pub const AV_PKT_FLAG_CORRUPT: u32 = 2;
pub const AV_PKT_FLAG_DISCARD: u32 = 4;
pub const AV_PKT_FLAG_TRUSTED: u32 = 8;
pub const AV_PKT_FLAG_DISPOSABLE: u32 = 16;
pub const FF_COMPRESSION_DEFAULT: i32 = -1;
pub const FF_PRED_LEFT: u32 = 0;
pub const FF_PRED_PLANE: u32 = 1;
pub const FF_PRED_MEDIAN: u32 = 2;
pub const FF_CMP_SAD: u32 = 0;
pub const FF_CMP_SSE: u32 = 1;
pub const FF_CMP_SATD: u32 = 2;
pub const FF_CMP_DCT: u32 = 3;
pub const FF_CMP_PSNR: u32 = 4;
pub const FF_CMP_BIT: u32 = 5;
pub const FF_CMP_RD: u32 = 6;
pub const FF_CMP_ZERO: u32 = 7;
pub const FF_CMP_VSAD: u32 = 8;
pub const FF_CMP_VSSE: u32 = 9;
pub const FF_CMP_NSSE: u32 = 10;
pub const FF_CMP_W53: u32 = 11;
pub const FF_CMP_W97: u32 = 12;
pub const FF_CMP_DCTMAX: u32 = 13;
pub const FF_CMP_DCT264: u32 = 14;
pub const FF_CMP_MEDIAN_SAD: u32 = 15;
pub const FF_CMP_CHROMA: u32 = 256;
pub const SLICE_FLAG_CODED_ORDER: u32 = 1;
pub const SLICE_FLAG_ALLOW_FIELD: u32 = 2;
pub const SLICE_FLAG_ALLOW_PLANE: u32 = 4;
pub const FF_MB_DECISION_SIMPLE: u32 = 0;
pub const FF_MB_DECISION_BITS: u32 = 1;
pub const FF_MB_DECISION_RD: u32 = 2;
pub const FF_CODER_TYPE_VLC: u32 = 0;
pub const FF_CODER_TYPE_AC: u32 = 1;
pub const FF_CODER_TYPE_RAW: u32 = 2;
pub const FF_CODER_TYPE_RLE: u32 = 3;
pub const FF_BUG_AUTODETECT: u32 = 1;
pub const FF_BUG_XVID_ILACE: u32 = 4;
pub const FF_BUG_UMP4: u32 = 8;
pub const FF_BUG_NO_PADDING: u32 = 16;
pub const FF_BUG_AMV: u32 = 32;
pub const FF_BUG_QPEL_CHROMA: u32 = 64;
pub const FF_BUG_STD_QPEL: u32 = 128;
pub const FF_BUG_QPEL_CHROMA2: u32 = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: u32 = 512;
pub const FF_BUG_EDGE: u32 = 1024;
pub const FF_BUG_HPEL_CHROMA: u32 = 2048;
pub const FF_BUG_DC_CLIP: u32 = 4096;
pub const FF_BUG_MS: u32 = 8192;
pub const FF_BUG_TRUNCATED: u32 = 16384;
pub const FF_BUG_IEDGE: u32 = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: u32 = 2;
pub const FF_COMPLIANCE_STRICT: u32 = 1;
pub const FF_COMPLIANCE_NORMAL: u32 = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: i32 = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: i32 = -2;
pub const FF_EC_GUESS_MVS: u32 = 1;
pub const FF_EC_DEBLOCK: u32 = 2;
pub const FF_EC_FAVOR_INTER: u32 = 256;
pub const FF_DEBUG_PICT_INFO: u32 = 1;
pub const FF_DEBUG_RC: u32 = 2;
pub const FF_DEBUG_BITSTREAM: u32 = 4;
pub const FF_DEBUG_MB_TYPE: u32 = 8;
pub const FF_DEBUG_QP: u32 = 16;
pub const FF_DEBUG_DCT_COEFF: u32 = 64;
pub const FF_DEBUG_SKIP: u32 = 128;
pub const FF_DEBUG_STARTCODE: u32 = 256;
pub const FF_DEBUG_ER: u32 = 1024;
pub const FF_DEBUG_MMCO: u32 = 2048;
pub const FF_DEBUG_BUGS: u32 = 4096;
pub const FF_DEBUG_BUFFERS: u32 = 32768;
pub const FF_DEBUG_THREADS: u32 = 65536;
pub const FF_DEBUG_GREEN_MD: u32 = 8388608;
pub const FF_DEBUG_NOMC: u32 = 16777216;
pub const AV_EF_CRCCHECK: u32 = 1;
pub const AV_EF_BITSTREAM: u32 = 2;
pub const AV_EF_BUFFER: u32 = 4;
pub const AV_EF_EXPLODE: u32 = 8;
pub const AV_EF_IGNORE_ERR: u32 = 32768;
pub const AV_EF_CAREFUL: u32 = 65536;
pub const AV_EF_COMPLIANT: u32 = 131072;
pub const AV_EF_AGGRESSIVE: u32 = 262144;
pub const FF_DCT_AUTO: u32 = 0;
pub const FF_DCT_FASTINT: u32 = 1;
pub const FF_DCT_INT: u32 = 2;
pub const FF_DCT_MMX: u32 = 3;
pub const FF_DCT_ALTIVEC: u32 = 5;
pub const FF_DCT_FAAN: u32 = 6;
pub const FF_IDCT_AUTO: u32 = 0;
pub const FF_IDCT_INT: u32 = 1;
pub const FF_IDCT_SIMPLE: u32 = 2;
pub const FF_IDCT_SIMPLEMMX: u32 = 3;
pub const FF_IDCT_ARM: u32 = 7;
pub const FF_IDCT_ALTIVEC: u32 = 8;
pub const FF_IDCT_SIMPLEARM: u32 = 10;
pub const FF_IDCT_XVID: u32 = 14;
pub const FF_IDCT_SIMPLEARMV5TE: u32 = 16;
pub const FF_IDCT_SIMPLEARMV6: u32 = 17;
pub const FF_IDCT_FAAN: u32 = 20;
pub const FF_IDCT_SIMPLENEON: u32 = 22;
pub const FF_IDCT_NONE: u32 = 24;
pub const FF_IDCT_SIMPLEAUTO: u32 = 128;
pub const FF_THREAD_FRAME: u32 = 1;
pub const FF_THREAD_SLICE: u32 = 2;
pub const FF_PROFILE_UNKNOWN: i32 = -99;
pub const FF_PROFILE_RESERVED: i32 = -100;
pub const FF_PROFILE_AAC_MAIN: u32 = 0;
pub const FF_PROFILE_AAC_LOW: u32 = 1;
pub const FF_PROFILE_AAC_SSR: u32 = 2;
pub const FF_PROFILE_AAC_LTP: u32 = 3;
pub const FF_PROFILE_AAC_HE: u32 = 4;
pub const FF_PROFILE_AAC_HE_V2: u32 = 28;
pub const FF_PROFILE_AAC_LD: u32 = 22;
pub const FF_PROFILE_AAC_ELD: u32 = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const FF_PROFILE_DNXHD: u32 = 0;
pub const FF_PROFILE_DNXHR_LB: u32 = 1;
pub const FF_PROFILE_DNXHR_SQ: u32 = 2;
pub const FF_PROFILE_DNXHR_HQ: u32 = 3;
pub const FF_PROFILE_DNXHR_HQX: u32 = 4;
pub const FF_PROFILE_DNXHR_444: u32 = 5;
pub const FF_PROFILE_DTS: u32 = 20;
pub const FF_PROFILE_DTS_ES: u32 = 30;
pub const FF_PROFILE_DTS_96_24: u32 = 40;
pub const FF_PROFILE_DTS_HD_HRA: u32 = 50;
pub const FF_PROFILE_DTS_HD_MA: u32 = 60;
pub const FF_PROFILE_DTS_EXPRESS: u32 = 70;
pub const FF_PROFILE_MPEG2_422: u32 = 0;
pub const FF_PROFILE_MPEG2_HIGH: u32 = 1;
pub const FF_PROFILE_MPEG2_SS: u32 = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const FF_PROFILE_MPEG2_MAIN: u32 = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const FF_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const FF_PROFILE_H264_INTRA: u32 = 2048;
pub const FF_PROFILE_H264_BASELINE: u32 = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const FF_PROFILE_H264_MAIN: u32 = 77;
pub const FF_PROFILE_H264_EXTENDED: u32 = 88;
pub const FF_PROFILE_H264_HIGH: u32 = 100;
pub const FF_PROFILE_H264_HIGH_10: u32 = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const FF_PROFILE_H264_HIGH_422: u32 = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const FF_PROFILE_H264_HIGH_444: u32 = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const FF_PROFILE_H264_CAVLC_444: u32 = 44;
pub const FF_PROFILE_VC1_SIMPLE: u32 = 0;
pub const FF_PROFILE_VC1_MAIN: u32 = 1;
pub const FF_PROFILE_VC1_COMPLEX: u32 = 2;
pub const FF_PROFILE_VC1_ADVANCED: u32 = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const FF_PROFILE_MPEG4_CORE: u32 = 2;
pub const FF_PROFILE_MPEG4_MAIN: u32 = 3;
pub const FF_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const FF_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const FF_PROFILE_VP9_0: u32 = 0;
pub const FF_PROFILE_VP9_1: u32 = 1;
pub const FF_PROFILE_VP9_2: u32 = 2;
pub const FF_PROFILE_VP9_3: u32 = 3;
pub const FF_PROFILE_HEVC_MAIN: u32 = 1;
pub const FF_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const FF_PROFILE_HEVC_REXT: u32 = 4;
pub const FF_PROFILE_AV1_MAIN: u32 = 0;
pub const FF_PROFILE_AV1_HIGH: u32 = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: u32 = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: u32 = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: u32 = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: u32 = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: u32 = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: u32 = 247;
pub const FF_PROFILE_SBC_MSBC: u32 = 1;
pub const FF_PROFILE_PRORES_PROXY: u32 = 0;
pub const FF_PROFILE_PRORES_LT: u32 = 1;
pub const FF_PROFILE_PRORES_STANDARD: u32 = 2;
pub const FF_PROFILE_PRORES_HQ: u32 = 3;
pub const FF_PROFILE_PRORES_4444: u32 = 4;
pub const FF_PROFILE_PRORES_XQ: u32 = 5;
pub const FF_LEVEL_UNKNOWN: i32 = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: i32 = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: u32 = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: u32 = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: u32 = 2;
pub const FF_DEBUG_VIS_MV_P_FOR: u32 = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: u32 = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: u32 = 4;
pub const FF_CODEC_PROPERTY_LOSSLESS: u32 = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: u32 = 2;
pub const FF_SUB_TEXT_FMT_ASS: u32 = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: u32 = 1;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: u32 = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: u32 = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: u32 = 4;
pub const AV_SUBTITLE_FLAG_FORCED: u32 = 1;
pub const AV_PARSER_PTS_NB: u32 = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: u32 = 1;
pub const PARSER_FLAG_ONCE: u32 = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: u32 = 4;
pub const PARSER_FLAG_USE_CODEC_TS: u32 = 4096;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
pub type AVMediaType = i32;
extern "C" {
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
pub type AVPictureType = i32;
extern "C" {
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout__Lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_Lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type imaxdiv_t = _Lldiv_t;
extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout__exception() {
    assert_eq!(
        ::std::mem::size_of::<_exception>(),
        40usize,
        concat!("Size of: ", stringify!(_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(_exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(retval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__complex() {
    assert_eq!(
        ::std::mem::size_of::<_complex>(),
        16usize,
        concat!("Size of: ", stringify!(_complex))
    );
    assert_eq!(
        ::std::mem::align_of::<_complex>(),
        8usize,
        concat!("Alignment of ", stringify!(_complex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(y)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "\u{1}_HUGE"]
    pub static _HUGE: f64;
}
extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__double_val() {
    assert_eq!(
        ::std::mem::size_of::<_double_val>(),
        8usize,
        concat!("Size of: ", stringify!(_double_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_double_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_double_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__float_val() {
    assert_eq!(
        ::std::mem::size_of::<_float_val>(),
        4usize,
        concat!("Size of: ", stringify!(_float_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_val>(),
        4usize,
        concat!("Alignment of ", stringify!(_float_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__ldouble_val() {
    assert_eq!(
        ::std::mem::size_of::<_ldouble_val>(),
        8usize,
        concat!("Size of: ", stringify!(_ldouble_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldouble_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_ldouble_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__float_const() {
    assert_eq!(
        ::std::mem::size_of::<_float_const>(),
        8usize,
        concat!("Size of: ", stringify!(_float_const))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_const>(),
        8usize,
        concat!("Alignment of ", stringify!(_float_const))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Long_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Long_double)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Denorm_C"]
    pub static _Denorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Inf_C"]
    pub static _Inf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Nan_C"]
    pub static _Nan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Snan_C"]
    pub static _Snan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Hugeval_C"]
    pub static _Hugeval_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FDenorm_C"]
    pub static _FDenorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FInf_C"]
    pub static _FInf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FNan_C"]
    pub static _FNan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FSnan_C"]
    pub static _FSnan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LDenorm_C"]
    pub static _LDenorm_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LInf_C"]
    pub static _LInf_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LNan_C"]
    pub static _LNan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LSnan_C"]
    pub static _LSnan_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Eps_C"]
    pub static _Eps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Rteps_C"]
    pub static _Rteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FEps_C"]
    pub static _FEps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_FRteps_C"]
    pub static _FRteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LEps_C"]
    pub static _LEps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_LRteps_C"]
    pub static _LRteps_C: _float_const;
}
extern "C" {
    #[link_name = "\u{1}_Zero_C"]
    pub static _Zero_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_Xbig_C"]
    pub static _Xbig_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_FZero_C"]
    pub static _FZero_C: f32;
}
extern "C" {
    #[link_name = "\u{1}_FXbig_C"]
    pub static _FXbig_C: f32;
}
extern "C" {
    #[link_name = "\u{1}_LZero_C"]
    pub static _LZero_C: f64;
}
extern "C" {
    #[link_name = "\u{1}_LXbig_C"]
    pub static _LXbig_C: f64;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erf(_X: f64) -> f64;
}
extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
extern "C" {
    pub fn log2(_X: f64) -> f64;
}
extern "C" {
    pub fn logb(_X: f64) -> f64;
}
extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(_X: f64) -> f64;
}
extern "C" {
    pub fn round(_X: f64) -> f64;
}
extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn erff(_X: f32) -> f32;
}
extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
extern "C" {
    pub fn logf(_X: f32) -> f32;
}
extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}HUGE"]
    pub static mut HUGE: f64;
}
extern "C" {
    pub fn j0(_X: f64) -> f64;
}
extern "C" {
    pub fn j1(_X: f64) -> f64;
}
extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn y0(_X: f64) -> f64;
}
extern "C" {
    pub fn y1(_X: f64) -> f64;
}
extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_iobuf>()))._Placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDOUBLE>())).ld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_DOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_FLOAT>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LONGDOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDBL12>())).ld12 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const wchar_t) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_max_alloc(max: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    pub num: ::std::os::raw::c_int,
    pub den: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    assert_eq!(
        ::std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
pub type AVRounding = i32;
extern "C" {
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub type __gnuc_va_list = __builtin_va_list;
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    pub class_name: *const ::std::os::raw::c_char,
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub option: *mut AVOption,
    pub version: ::std::os::raw::c_int,
    pub log_level_offset_offset: ::std::os::raw::c_int,
    pub parent_log_context_offset: ::std::os::raw::c_int,
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut ::std::os::raw::c_void, prev: *mut ::std::os::raw::c_void)
            -> *mut ::std::os::raw::c_void,
    >,
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    pub category: AVClassCategory,
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(
        ::std::mem::size_of::<AVClass>(),
        80usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        ::std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).class_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).item_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).category as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).get_category as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
}
extern "C" {
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 58;
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 58;
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 103;
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 116;
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 117;
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 119;
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 120;
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 121;
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 122;
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 123;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 153;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 161;
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 162;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 172;
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 173;
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 174;
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 183;
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 184;
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 185;
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 186;
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 187;
pub type AVPixelFormat = i32;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
pub type AVColorPrimaries = i32;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
pub type AVColorTransferCharacteristic = i32;
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
pub type AVColorSpace = i32;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
pub type AVColorRange = i32;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
pub type AVChromaLocation = i32;
extern "C" {
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
pub type AVSampleFormat = i32;
extern "C" {
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferRef>(),
        24usize,
        concat!("Size of: ", stringify!(AVBufferRef))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn av_buffer_alloc(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(
        data: *mut u8,
        size: ::std::os::raw::c_int,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(
        buf: *mut *mut AVBufferRef,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(
        size: ::std::os::raw::c_int,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut AVBufferRef,
        >,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(
        size: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_int)
                -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_get_cpu_flags() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_force_cpu_flags(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_set_cpu_flags_mask(mask: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_parse_cpu_flags(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parse_cpu_caps(
        flags: *mut ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_cpu_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_cpu_max_align() -> usize;
}
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = i32;
extern "C" {
    pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn av_get_extended_channel_layout(
        name: *const ::std::os::raw::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_channel_layout_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn av_get_channel_layout_channel_index(
        channel_layout: u64,
        channel: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_extract_channel(
        channel_layout: u64,
        index: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_standard_channel_layout(
        index: ::std::os::raw::c_uint,
        layout: *mut u64,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVDictionaryEntry>(),
        16usize,
        concat!("Size of: ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDictionaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_PROPERTIES: AVFrameSideDataType = 16;
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_DATA: AVFrameSideDataType = 17;
pub const AVFrameSideDataType_AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 18;
pub type AVFrameSideDataType = i32;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVFrameSideData>(),
        40usize,
        concat!("Size of: ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrameSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).metadata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrame {
    pub data: [*mut u8; 8usize],
    pub linesize: [::std::os::raw::c_int; 8usize],
    pub extended_data: *mut *mut u8,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub nb_samples: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub key_frame: ::std::os::raw::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: i64,
    pub pkt_pts: i64,
    pub pkt_dts: i64,
    pub coded_picture_number: ::std::os::raw::c_int,
    pub display_picture_number: ::std::os::raw::c_int,
    pub quality: ::std::os::raw::c_int,
    pub opaque: *mut ::std::os::raw::c_void,
    pub error: [u64; 8usize],
    pub repeat_pict: ::std::os::raw::c_int,
    pub interlaced_frame: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub palette_has_changed: ::std::os::raw::c_int,
    pub reordered_opaque: i64,
    pub sample_rate: ::std::os::raw::c_int,
    pub channel_layout: u64,
    pub buf: [*mut AVBufferRef; 8usize],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: i64,
    pub pkt_pos: i64,
    pub pkt_duration: i64,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub pkt_size: ::std::os::raw::c_int,
    pub qscale_table: *mut i8,
    pub qstride: ::std::os::raw::c_int,
    pub qscale_type: ::std::os::raw::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub opaque_ref: *mut AVBufferRef,
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    pub private_ref: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    assert_eq!(
        ::std::mem::size_of::<AVFrame>(),
        536usize,
        concat!("Size of: ", stringify!(AVFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).width as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).height as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_samples as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).format as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).key_frame as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pict_type as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_aspect_ratio as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pts as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_dts as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).coded_picture_number as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(coded_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).display_picture_number as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(display_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).quality as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).error as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).repeat_pict as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).interlaced_frame as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(interlaced_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).top_field_first as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).palette_has_changed as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(palette_has_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).reordered_opaque as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_rate as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channel_layout as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).buf as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_buf as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_extended_buf as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).side_data as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_side_data as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).flags as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_range as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_primaries as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_trc as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).colorspace as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).chroma_location as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).best_effort_timestamp as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(best_effort_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pos as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_duration as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).metadata as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).decode_error_flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(decode_error_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channels as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_size as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_table as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qstride as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qstride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_type as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qp_table_buf as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qp_table_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).hw_frames_ctx as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque_ref as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_top as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_bottom as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_left as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_right as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).private_ref as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(private_ref)
        )
    );
}
extern "C" {
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_plane_buffer(
        frame: *mut AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = i32;
extern "C" {
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_NONE: AVHWDeviceType = 0;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VDPAU: AVHWDeviceType = 1;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_CUDA: AVHWDeviceType = 2;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VAAPI: AVHWDeviceType = 3;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DXVA2: AVHWDeviceType = 4;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_QSV: AVHWDeviceType = 5;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VIDEOTOOLBOX: AVHWDeviceType = 6;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_D3D11VA: AVHWDeviceType = 7;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DRM: AVHWDeviceType = 8;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_OPENCL: AVHWDeviceType = 9;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_MEDIACODEC: AVHWDeviceType = 10;
pub type AVHWDeviceType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWDeviceInternal,
    pub type_: AVHWDeviceType,
    pub hwctx: *mut ::std::os::raw::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    pub user_opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AVHWDeviceContext() {
    assert_eq!(
        ::std::mem::size_of::<AVHWDeviceContext>(),
        48usize,
        concat!("Size of: ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWDeviceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).hwctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).user_opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(user_opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWFramesInternal,
    pub device_ref: *mut AVBufferRef,
    pub device_ctx: *mut AVHWDeviceContext,
    pub hwctx: *mut ::std::os::raw::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    pub user_opaque: *mut ::std::os::raw::c_void,
    pub pool: *mut AVBufferPool,
    pub initial_pool_size: ::std::os::raw::c_int,
    pub format: AVPixelFormat,
    pub sw_format: AVPixelFormat,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesContext() {
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesContext>(),
        88usize,
        concat!("Size of: ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).device_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).device_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).hwctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).user_opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(user_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).pool as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesContext>())).initial_pool_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(initial_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).sw_format as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(sw_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).width as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).height as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_find_type_by_name(name: *const ::std::os::raw::c_char) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const ::std::os::raw::c_char,
        opts: *mut AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_FROM:
    AVHWFrameTransferDirection = 0;
pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_TO: AVHWFrameTransferDirection =
    1;
pub type AVHWFrameTransferDirection = i32;
extern "C" {
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesConstraints {
    pub valid_hw_formats: *mut AVPixelFormat,
    pub valid_sw_formats: *mut AVPixelFormat,
    pub min_width: ::std::os::raw::c_int,
    pub min_height: ::std::os::raw::c_int,
    pub max_width: ::std::os::raw::c_int,
    pub max_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesConstraints() {
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesConstraints>(),
        32usize,
        concat!("Size of: ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesConstraints>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).valid_hw_formats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_hw_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).valid_sw_formats as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_sw_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesConstraints>())).min_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).min_height as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesConstraints>())).max_width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).max_height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const ::std::os::raw::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_2 = 1;
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_2 = 2;
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_2 = 4;
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_2 = 8;
pub type _bindgen_ty_2 = i32;
extern "C" {
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AVCodecID_AV_CODEC_ID_NONE: AVCodecID = 0;
pub const AVCodecID_AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
///< preferred ID for MPEG-1/2 video decoding
pub const AVCodecID_AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
pub const AVCodecID_AV_CODEC_ID_H261: AVCodecID = 3;
pub const AVCodecID_AV_CODEC_ID_H263: AVCodecID = 4;
pub const AVCodecID_AV_CODEC_ID_RV10: AVCodecID = 5;
pub const AVCodecID_AV_CODEC_ID_RV20: AVCodecID = 6;
pub const AVCodecID_AV_CODEC_ID_MJPEG: AVCodecID = 7;
pub const AVCodecID_AV_CODEC_ID_MJPEGB: AVCodecID = 8;
pub const AVCodecID_AV_CODEC_ID_LJPEG: AVCodecID = 9;
pub const AVCodecID_AV_CODEC_ID_SP5X: AVCodecID = 10;
pub const AVCodecID_AV_CODEC_ID_JPEGLS: AVCodecID = 11;
pub const AVCodecID_AV_CODEC_ID_MPEG4: AVCodecID = 12;
pub const AVCodecID_AV_CODEC_ID_RAWVIDEO: AVCodecID = 13;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V1: AVCodecID = 14;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V2: AVCodecID = 15;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V3: AVCodecID = 16;
pub const AVCodecID_AV_CODEC_ID_WMV1: AVCodecID = 17;
pub const AVCodecID_AV_CODEC_ID_WMV2: AVCodecID = 18;
pub const AVCodecID_AV_CODEC_ID_H263P: AVCodecID = 19;
pub const AVCodecID_AV_CODEC_ID_H263I: AVCodecID = 20;
pub const AVCodecID_AV_CODEC_ID_FLV1: AVCodecID = 21;
pub const AVCodecID_AV_CODEC_ID_SVQ1: AVCodecID = 22;
pub const AVCodecID_AV_CODEC_ID_SVQ3: AVCodecID = 23;
pub const AVCodecID_AV_CODEC_ID_DVVIDEO: AVCodecID = 24;
pub const AVCodecID_AV_CODEC_ID_HUFFYUV: AVCodecID = 25;
pub const AVCodecID_AV_CODEC_ID_CYUV: AVCodecID = 26;
pub const AVCodecID_AV_CODEC_ID_H264: AVCodecID = 27;
pub const AVCodecID_AV_CODEC_ID_INDEO3: AVCodecID = 28;
pub const AVCodecID_AV_CODEC_ID_VP3: AVCodecID = 29;
pub const AVCodecID_AV_CODEC_ID_THEORA: AVCodecID = 30;
pub const AVCodecID_AV_CODEC_ID_ASV1: AVCodecID = 31;
pub const AVCodecID_AV_CODEC_ID_ASV2: AVCodecID = 32;
pub const AVCodecID_AV_CODEC_ID_FFV1: AVCodecID = 33;
pub const AVCodecID_AV_CODEC_ID_4XM: AVCodecID = 34;
pub const AVCodecID_AV_CODEC_ID_VCR1: AVCodecID = 35;
pub const AVCodecID_AV_CODEC_ID_CLJR: AVCodecID = 36;
pub const AVCodecID_AV_CODEC_ID_MDEC: AVCodecID = 37;
pub const AVCodecID_AV_CODEC_ID_ROQ: AVCodecID = 38;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 39;
pub const AVCodecID_AV_CODEC_ID_XAN_WC3: AVCodecID = 40;
pub const AVCodecID_AV_CODEC_ID_XAN_WC4: AVCodecID = 41;
pub const AVCodecID_AV_CODEC_ID_RPZA: AVCodecID = 42;
pub const AVCodecID_AV_CODEC_ID_CINEPAK: AVCodecID = 43;
pub const AVCodecID_AV_CODEC_ID_WS_VQA: AVCodecID = 44;
pub const AVCodecID_AV_CODEC_ID_MSRLE: AVCodecID = 45;
pub const AVCodecID_AV_CODEC_ID_MSVIDEO1: AVCodecID = 46;
pub const AVCodecID_AV_CODEC_ID_IDCIN: AVCodecID = 47;
pub const AVCodecID_AV_CODEC_ID_8BPS: AVCodecID = 48;
pub const AVCodecID_AV_CODEC_ID_SMC: AVCodecID = 49;
pub const AVCodecID_AV_CODEC_ID_FLIC: AVCodecID = 50;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION1: AVCodecID = 51;
pub const AVCodecID_AV_CODEC_ID_VMDVIDEO: AVCodecID = 52;
pub const AVCodecID_AV_CODEC_ID_MSZH: AVCodecID = 53;
pub const AVCodecID_AV_CODEC_ID_ZLIB: AVCodecID = 54;
pub const AVCodecID_AV_CODEC_ID_QTRLE: AVCodecID = 55;
pub const AVCodecID_AV_CODEC_ID_TSCC: AVCodecID = 56;
pub const AVCodecID_AV_CODEC_ID_ULTI: AVCodecID = 57;
pub const AVCodecID_AV_CODEC_ID_QDRAW: AVCodecID = 58;
pub const AVCodecID_AV_CODEC_ID_VIXL: AVCodecID = 59;
pub const AVCodecID_AV_CODEC_ID_QPEG: AVCodecID = 60;
pub const AVCodecID_AV_CODEC_ID_PNG: AVCodecID = 61;
pub const AVCodecID_AV_CODEC_ID_PPM: AVCodecID = 62;
pub const AVCodecID_AV_CODEC_ID_PBM: AVCodecID = 63;
pub const AVCodecID_AV_CODEC_ID_PGM: AVCodecID = 64;
pub const AVCodecID_AV_CODEC_ID_PGMYUV: AVCodecID = 65;
pub const AVCodecID_AV_CODEC_ID_PAM: AVCodecID = 66;
pub const AVCodecID_AV_CODEC_ID_FFVHUFF: AVCodecID = 67;
pub const AVCodecID_AV_CODEC_ID_RV30: AVCodecID = 68;
pub const AVCodecID_AV_CODEC_ID_RV40: AVCodecID = 69;
pub const AVCodecID_AV_CODEC_ID_VC1: AVCodecID = 70;
pub const AVCodecID_AV_CODEC_ID_WMV3: AVCodecID = 71;
pub const AVCodecID_AV_CODEC_ID_LOCO: AVCodecID = 72;
pub const AVCodecID_AV_CODEC_ID_WNV1: AVCodecID = 73;
pub const AVCodecID_AV_CODEC_ID_AASC: AVCodecID = 74;
pub const AVCodecID_AV_CODEC_ID_INDEO2: AVCodecID = 75;
pub const AVCodecID_AV_CODEC_ID_FRAPS: AVCodecID = 76;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2: AVCodecID = 77;
pub const AVCodecID_AV_CODEC_ID_BMP: AVCodecID = 78;
pub const AVCodecID_AV_CODEC_ID_CSCD: AVCodecID = 79;
pub const AVCodecID_AV_CODEC_ID_MMVIDEO: AVCodecID = 80;
pub const AVCodecID_AV_CODEC_ID_ZMBV: AVCodecID = 81;
pub const AVCodecID_AV_CODEC_ID_AVS: AVCodecID = 82;
pub const AVCodecID_AV_CODEC_ID_SMACKVIDEO: AVCodecID = 83;
pub const AVCodecID_AV_CODEC_ID_NUV: AVCodecID = 84;
pub const AVCodecID_AV_CODEC_ID_KMVC: AVCodecID = 85;
pub const AVCodecID_AV_CODEC_ID_FLASHSV: AVCodecID = 86;
pub const AVCodecID_AV_CODEC_ID_CAVS: AVCodecID = 87;
pub const AVCodecID_AV_CODEC_ID_JPEG2000: AVCodecID = 88;
pub const AVCodecID_AV_CODEC_ID_VMNC: AVCodecID = 89;
pub const AVCodecID_AV_CODEC_ID_VP5: AVCodecID = 90;
pub const AVCodecID_AV_CODEC_ID_VP6: AVCodecID = 91;
pub const AVCodecID_AV_CODEC_ID_VP6F: AVCodecID = 92;
pub const AVCodecID_AV_CODEC_ID_TARGA: AVCodecID = 93;
pub const AVCodecID_AV_CODEC_ID_DSICINVIDEO: AVCodecID = 94;
pub const AVCodecID_AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 95;
pub const AVCodecID_AV_CODEC_ID_TIFF: AVCodecID = 96;
pub const AVCodecID_AV_CODEC_ID_GIF: AVCodecID = 97;
pub const AVCodecID_AV_CODEC_ID_DXA: AVCodecID = 98;
pub const AVCodecID_AV_CODEC_ID_DNXHD: AVCodecID = 99;
pub const AVCodecID_AV_CODEC_ID_THP: AVCodecID = 100;
pub const AVCodecID_AV_CODEC_ID_SGI: AVCodecID = 101;
pub const AVCodecID_AV_CODEC_ID_C93: AVCodecID = 102;
pub const AVCodecID_AV_CODEC_ID_BETHSOFTVID: AVCodecID = 103;
pub const AVCodecID_AV_CODEC_ID_PTX: AVCodecID = 104;
pub const AVCodecID_AV_CODEC_ID_TXD: AVCodecID = 105;
pub const AVCodecID_AV_CODEC_ID_VP6A: AVCodecID = 106;
pub const AVCodecID_AV_CODEC_ID_AMV: AVCodecID = 107;
pub const AVCodecID_AV_CODEC_ID_VB: AVCodecID = 108;
pub const AVCodecID_AV_CODEC_ID_PCX: AVCodecID = 109;
pub const AVCodecID_AV_CODEC_ID_SUNRAST: AVCodecID = 110;
pub const AVCodecID_AV_CODEC_ID_INDEO4: AVCodecID = 111;
pub const AVCodecID_AV_CODEC_ID_INDEO5: AVCodecID = 112;
pub const AVCodecID_AV_CODEC_ID_MIMIC: AVCodecID = 113;
pub const AVCodecID_AV_CODEC_ID_RL2: AVCodecID = 114;
pub const AVCodecID_AV_CODEC_ID_ESCAPE124: AVCodecID = 115;
pub const AVCodecID_AV_CODEC_ID_DIRAC: AVCodecID = 116;
pub const AVCodecID_AV_CODEC_ID_BFI: AVCodecID = 117;
pub const AVCodecID_AV_CODEC_ID_CMV: AVCodecID = 118;
pub const AVCodecID_AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 119;
pub const AVCodecID_AV_CODEC_ID_TGV: AVCodecID = 120;
pub const AVCodecID_AV_CODEC_ID_TGQ: AVCodecID = 121;
pub const AVCodecID_AV_CODEC_ID_TQI: AVCodecID = 122;
pub const AVCodecID_AV_CODEC_ID_AURA: AVCodecID = 123;
pub const AVCodecID_AV_CODEC_ID_AURA2: AVCodecID = 124;
pub const AVCodecID_AV_CODEC_ID_V210X: AVCodecID = 125;
pub const AVCodecID_AV_CODEC_ID_TMV: AVCodecID = 126;
pub const AVCodecID_AV_CODEC_ID_V210: AVCodecID = 127;
pub const AVCodecID_AV_CODEC_ID_DPX: AVCodecID = 128;
pub const AVCodecID_AV_CODEC_ID_MAD: AVCodecID = 129;
pub const AVCodecID_AV_CODEC_ID_FRWU: AVCodecID = 130;
pub const AVCodecID_AV_CODEC_ID_FLASHSV2: AVCodecID = 131;
pub const AVCodecID_AV_CODEC_ID_CDGRAPHICS: AVCodecID = 132;
pub const AVCodecID_AV_CODEC_ID_R210: AVCodecID = 133;
pub const AVCodecID_AV_CODEC_ID_ANM: AVCodecID = 134;
pub const AVCodecID_AV_CODEC_ID_BINKVIDEO: AVCodecID = 135;
pub const AVCodecID_AV_CODEC_ID_IFF_ILBM: AVCodecID = 136;
pub const AVCodecID_AV_CODEC_ID_KGV1: AVCodecID = 137;
pub const AVCodecID_AV_CODEC_ID_YOP: AVCodecID = 138;
pub const AVCodecID_AV_CODEC_ID_VP8: AVCodecID = 139;
pub const AVCodecID_AV_CODEC_ID_PICTOR: AVCodecID = 140;
pub const AVCodecID_AV_CODEC_ID_ANSI: AVCodecID = 141;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI: AVCodecID = 142;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI5: AVCodecID = 143;
pub const AVCodecID_AV_CODEC_ID_R10K: AVCodecID = 144;
pub const AVCodecID_AV_CODEC_ID_MXPEG: AVCodecID = 145;
pub const AVCodecID_AV_CODEC_ID_LAGARITH: AVCodecID = 146;
pub const AVCodecID_AV_CODEC_ID_PRORES: AVCodecID = 147;
pub const AVCodecID_AV_CODEC_ID_JV: AVCodecID = 148;
pub const AVCodecID_AV_CODEC_ID_DFA: AVCodecID = 149;
pub const AVCodecID_AV_CODEC_ID_WMV3IMAGE: AVCodecID = 150;
pub const AVCodecID_AV_CODEC_ID_VC1IMAGE: AVCodecID = 151;
pub const AVCodecID_AV_CODEC_ID_UTVIDEO: AVCodecID = 152;
pub const AVCodecID_AV_CODEC_ID_BMV_VIDEO: AVCodecID = 153;
pub const AVCodecID_AV_CODEC_ID_VBLE: AVCodecID = 154;
pub const AVCodecID_AV_CODEC_ID_DXTORY: AVCodecID = 155;
pub const AVCodecID_AV_CODEC_ID_V410: AVCodecID = 156;
pub const AVCodecID_AV_CODEC_ID_XWD: AVCodecID = 157;
pub const AVCodecID_AV_CODEC_ID_CDXL: AVCodecID = 158;
pub const AVCodecID_AV_CODEC_ID_XBM: AVCodecID = 159;
pub const AVCodecID_AV_CODEC_ID_ZEROCODEC: AVCodecID = 160;
pub const AVCodecID_AV_CODEC_ID_MSS1: AVCodecID = 161;
pub const AVCodecID_AV_CODEC_ID_MSA1: AVCodecID = 162;
pub const AVCodecID_AV_CODEC_ID_TSCC2: AVCodecID = 163;
pub const AVCodecID_AV_CODEC_ID_MTS2: AVCodecID = 164;
pub const AVCodecID_AV_CODEC_ID_CLLC: AVCodecID = 165;
pub const AVCodecID_AV_CODEC_ID_MSS2: AVCodecID = 166;
pub const AVCodecID_AV_CODEC_ID_VP9: AVCodecID = 167;
pub const AVCodecID_AV_CODEC_ID_AIC: AVCodecID = 168;
pub const AVCodecID_AV_CODEC_ID_ESCAPE130: AVCodecID = 169;
pub const AVCodecID_AV_CODEC_ID_G2M: AVCodecID = 170;
pub const AVCodecID_AV_CODEC_ID_WEBP: AVCodecID = 171;
pub const AVCodecID_AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 172;
pub const AVCodecID_AV_CODEC_ID_HEVC: AVCodecID = 173;
pub const AVCodecID_AV_CODEC_ID_FIC: AVCodecID = 174;
pub const AVCodecID_AV_CODEC_ID_ALIAS_PIX: AVCodecID = 175;
pub const AVCodecID_AV_CODEC_ID_BRENDER_PIX: AVCodecID = 176;
pub const AVCodecID_AV_CODEC_ID_PAF_VIDEO: AVCodecID = 177;
pub const AVCodecID_AV_CODEC_ID_EXR: AVCodecID = 178;
pub const AVCodecID_AV_CODEC_ID_VP7: AVCodecID = 179;
pub const AVCodecID_AV_CODEC_ID_SANM: AVCodecID = 180;
pub const AVCodecID_AV_CODEC_ID_SGIRLE: AVCodecID = 181;
pub const AVCodecID_AV_CODEC_ID_MVC1: AVCodecID = 182;
pub const AVCodecID_AV_CODEC_ID_MVC2: AVCodecID = 183;
pub const AVCodecID_AV_CODEC_ID_HQX: AVCodecID = 184;
pub const AVCodecID_AV_CODEC_ID_TDSC: AVCodecID = 185;
pub const AVCodecID_AV_CODEC_ID_HQ_HQA: AVCodecID = 186;
pub const AVCodecID_AV_CODEC_ID_HAP: AVCodecID = 187;
pub const AVCodecID_AV_CODEC_ID_DDS: AVCodecID = 188;
pub const AVCodecID_AV_CODEC_ID_DXV: AVCodecID = 189;
pub const AVCodecID_AV_CODEC_ID_SCREENPRESSO: AVCodecID = 190;
pub const AVCodecID_AV_CODEC_ID_RSCC: AVCodecID = 191;
pub const AVCodecID_AV_CODEC_ID_AVS2: AVCodecID = 192;
pub const AVCodecID_AV_CODEC_ID_Y41P: AVCodecID = 32768;
pub const AVCodecID_AV_CODEC_ID_AVRP: AVCodecID = 32769;
pub const AVCodecID_AV_CODEC_ID_012V: AVCodecID = 32770;
pub const AVCodecID_AV_CODEC_ID_AVUI: AVCodecID = 32771;
pub const AVCodecID_AV_CODEC_ID_AYUV: AVCodecID = 32772;
pub const AVCodecID_AV_CODEC_ID_TARGA_Y216: AVCodecID = 32773;
pub const AVCodecID_AV_CODEC_ID_V308: AVCodecID = 32774;
pub const AVCodecID_AV_CODEC_ID_V408: AVCodecID = 32775;
pub const AVCodecID_AV_CODEC_ID_YUV4: AVCodecID = 32776;
pub const AVCodecID_AV_CODEC_ID_AVRN: AVCodecID = 32777;
pub const AVCodecID_AV_CODEC_ID_CPIA: AVCodecID = 32778;
pub const AVCodecID_AV_CODEC_ID_XFACE: AVCodecID = 32779;
pub const AVCodecID_AV_CODEC_ID_SNOW: AVCodecID = 32780;
pub const AVCodecID_AV_CODEC_ID_SMVJPEG: AVCodecID = 32781;
pub const AVCodecID_AV_CODEC_ID_APNG: AVCodecID = 32782;
pub const AVCodecID_AV_CODEC_ID_DAALA: AVCodecID = 32783;
pub const AVCodecID_AV_CODEC_ID_CFHD: AVCodecID = 32784;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 32785;
pub const AVCodecID_AV_CODEC_ID_M101: AVCodecID = 32786;
pub const AVCodecID_AV_CODEC_ID_MAGICYUV: AVCodecID = 32787;
pub const AVCodecID_AV_CODEC_ID_SHEERVIDEO: AVCodecID = 32788;
pub const AVCodecID_AV_CODEC_ID_YLC: AVCodecID = 32789;
pub const AVCodecID_AV_CODEC_ID_PSD: AVCodecID = 32790;
pub const AVCodecID_AV_CODEC_ID_PIXLET: AVCodecID = 32791;
pub const AVCodecID_AV_CODEC_ID_SPEEDHQ: AVCodecID = 32792;
pub const AVCodecID_AV_CODEC_ID_FMVC: AVCodecID = 32793;
pub const AVCodecID_AV_CODEC_ID_SCPR: AVCodecID = 32794;
pub const AVCodecID_AV_CODEC_ID_CLEARVIDEO: AVCodecID = 32795;
pub const AVCodecID_AV_CODEC_ID_XPM: AVCodecID = 32796;
pub const AVCodecID_AV_CODEC_ID_AV1: AVCodecID = 32797;
pub const AVCodecID_AV_CODEC_ID_BITPACKED: AVCodecID = 32798;
pub const AVCodecID_AV_CODEC_ID_MSCC: AVCodecID = 32799;
pub const AVCodecID_AV_CODEC_ID_SRGC: AVCodecID = 32800;
pub const AVCodecID_AV_CODEC_ID_SVG: AVCodecID = 32801;
pub const AVCodecID_AV_CODEC_ID_GDV: AVCodecID = 32802;
pub const AVCodecID_AV_CODEC_ID_FITS: AVCodecID = 32803;
pub const AVCodecID_AV_CODEC_ID_IMM4: AVCodecID = 32804;
pub const AVCodecID_AV_CODEC_ID_PROSUMER: AVCodecID = 32805;
pub const AVCodecID_AV_CODEC_ID_MWSC: AVCodecID = 32806;
pub const AVCodecID_AV_CODEC_ID_WCMV: AVCodecID = 32807;
pub const AVCodecID_AV_CODEC_ID_RASC: AVCodecID = 32808;
///< A dummy id pointing at the start of audio codecs
pub const AVCodecID_AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
pub const AVCodecID_AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
pub const AVCodecID_AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
pub const AVCodecID_AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
pub const AVCodecID_AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
pub const AVCodecID_AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
pub const AVCodecID_AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
pub const AVCodecID_AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
pub const AVCodecID_AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
pub const AVCodecID_AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
pub const AVCodecID_AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
pub const AVCodecID_AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
pub const AVCodecID_AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
pub const AVCodecID_AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
pub const AVCodecID_AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
pub const AVCodecID_AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
pub const AVCodecID_AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
pub const AVCodecID_AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
pub const AVCodecID_AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
pub const AVCodecID_AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
pub const AVCodecID_AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
pub const AVCodecID_AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
pub const AVCodecID_AV_CODEC_ID_S302M: AVCodecID = 65562;
pub const AVCodecID_AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
pub const AVCodecID_AV_CODEC_ID_PCM_S64LE: AVCodecID = 67584;
pub const AVCodecID_AV_CODEC_ID_PCM_S64BE: AVCodecID = 67585;
pub const AVCodecID_AV_CODEC_ID_PCM_F16LE: AVCodecID = 67586;
pub const AVCodecID_AV_CODEC_ID_PCM_F24LE: AVCodecID = 67587;
pub const AVCodecID_AV_CODEC_ID_PCM_VIDC: AVCodecID = 67588;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
pub const AVCodecID_AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
pub const AVCodecID_AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
pub const AVCodecID_AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
pub const AVCodecID_AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
pub const AVCodecID_AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
pub const AVCodecID_AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AFC: AVCodecID = 71680;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 71681;
pub const AVCodecID_AV_CODEC_ID_ADPCM_DTK: AVCodecID = 71682;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 71683;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 71684;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 71685;
pub const AVCodecID_AV_CODEC_ID_ADPCM_PSX: AVCodecID = 71686;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AICA: AVCodecID = 71687;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 71688;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 71689;
pub const AVCodecID_AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
pub const AVCodecID_AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
pub const AVCodecID_AV_CODEC_ID_RA_144: AVCodecID = 77824;
pub const AVCodecID_AV_CODEC_ID_RA_288: AVCodecID = 77825;
pub const AVCodecID_AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
pub const AVCodecID_AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
pub const AVCodecID_AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
pub const AVCodecID_AV_CODEC_ID_SDX2_DPCM: AVCodecID = 83968;
pub const AVCodecID_AV_CODEC_ID_GREMLIN_DPCM: AVCodecID = 83969;
pub const AVCodecID_AV_CODEC_ID_MP2: AVCodecID = 86016;
///< preferred ID for decoding MPEG audio layer 1, 2 or 3
pub const AVCodecID_AV_CODEC_ID_MP3: AVCodecID = 86017;
pub const AVCodecID_AV_CODEC_ID_AAC: AVCodecID = 86018;
pub const AVCodecID_AV_CODEC_ID_AC3: AVCodecID = 86019;
pub const AVCodecID_AV_CODEC_ID_DTS: AVCodecID = 86020;
pub const AVCodecID_AV_CODEC_ID_VORBIS: AVCodecID = 86021;
pub const AVCodecID_AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
pub const AVCodecID_AV_CODEC_ID_WMAV1: AVCodecID = 86023;
pub const AVCodecID_AV_CODEC_ID_WMAV2: AVCodecID = 86024;
pub const AVCodecID_AV_CODEC_ID_MACE3: AVCodecID = 86025;
pub const AVCodecID_AV_CODEC_ID_MACE6: AVCodecID = 86026;
pub const AVCodecID_AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
pub const AVCodecID_AV_CODEC_ID_FLAC: AVCodecID = 86028;
pub const AVCodecID_AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
pub const AVCodecID_AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
pub const AVCodecID_AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
pub const AVCodecID_AV_CODEC_ID_ALAC: AVCodecID = 86032;
pub const AVCodecID_AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
///< as in Berlin toast format
pub const AVCodecID_AV_CODEC_ID_GSM: AVCodecID = 86034;
pub const AVCodecID_AV_CODEC_ID_QDM2: AVCodecID = 86035;
pub const AVCodecID_AV_CODEC_ID_COOK: AVCodecID = 86036;
pub const AVCodecID_AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
pub const AVCodecID_AV_CODEC_ID_TTA: AVCodecID = 86038;
pub const AVCodecID_AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
pub const AVCodecID_AV_CODEC_ID_QCELP: AVCodecID = 86040;
pub const AVCodecID_AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
pub const AVCodecID_AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
pub const AVCodecID_AV_CODEC_ID_IMC: AVCodecID = 86043;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
pub const AVCodecID_AV_CODEC_ID_MLP: AVCodecID = 86045;
pub const AVCodecID_AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
pub const AVCodecID_AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
pub const AVCodecID_AV_CODEC_ID_APE: AVCodecID = 86048;
pub const AVCodecID_AV_CODEC_ID_NELLYMOSER: AVCodecID = 86049;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK8: AVCodecID = 86050;
pub const AVCodecID_AV_CODEC_ID_SPEEX: AVCodecID = 86051;
pub const AVCodecID_AV_CODEC_ID_WMAVOICE: AVCodecID = 86052;
pub const AVCodecID_AV_CODEC_ID_WMAPRO: AVCodecID = 86053;
pub const AVCodecID_AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86054;
pub const AVCodecID_AV_CODEC_ID_ATRAC3P: AVCodecID = 86055;
pub const AVCodecID_AV_CODEC_ID_EAC3: AVCodecID = 86056;
pub const AVCodecID_AV_CODEC_ID_SIPR: AVCodecID = 86057;
pub const AVCodecID_AV_CODEC_ID_MP1: AVCodecID = 86058;
pub const AVCodecID_AV_CODEC_ID_TWINVQ: AVCodecID = 86059;
pub const AVCodecID_AV_CODEC_ID_TRUEHD: AVCodecID = 86060;
pub const AVCodecID_AV_CODEC_ID_MP4ALS: AVCodecID = 86061;
pub const AVCodecID_AV_CODEC_ID_ATRAC1: AVCodecID = 86062;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86063;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86064;
pub const AVCodecID_AV_CODEC_ID_AAC_LATM: AVCodecID = 86065;
pub const AVCodecID_AV_CODEC_ID_QDMC: AVCodecID = 86066;
pub const AVCodecID_AV_CODEC_ID_CELT: AVCodecID = 86067;
pub const AVCodecID_AV_CODEC_ID_G723_1: AVCodecID = 86068;
pub const AVCodecID_AV_CODEC_ID_G729: AVCodecID = 86069;
pub const AVCodecID_AV_CODEC_ID_8SVX_EXP: AVCodecID = 86070;
pub const AVCodecID_AV_CODEC_ID_8SVX_FIB: AVCodecID = 86071;
pub const AVCodecID_AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86072;
pub const AVCodecID_AV_CODEC_ID_RALF: AVCodecID = 86073;
pub const AVCodecID_AV_CODEC_ID_IAC: AVCodecID = 86074;
pub const AVCodecID_AV_CODEC_ID_ILBC: AVCodecID = 86075;
pub const AVCodecID_AV_CODEC_ID_OPUS: AVCodecID = 86076;
pub const AVCodecID_AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86077;
pub const AVCodecID_AV_CODEC_ID_TAK: AVCodecID = 86078;
pub const AVCodecID_AV_CODEC_ID_METASOUND: AVCodecID = 86079;
pub const AVCodecID_AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86080;
pub const AVCodecID_AV_CODEC_ID_ON2AVC: AVCodecID = 86081;
pub const AVCodecID_AV_CODEC_ID_DSS_SP: AVCodecID = 86082;
pub const AVCodecID_AV_CODEC_ID_CODEC2: AVCodecID = 86083;
pub const AVCodecID_AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 88064;
pub const AVCodecID_AV_CODEC_ID_SONIC: AVCodecID = 88065;
pub const AVCodecID_AV_CODEC_ID_SONIC_LS: AVCodecID = 88066;
pub const AVCodecID_AV_CODEC_ID_EVRC: AVCodecID = 88067;
pub const AVCodecID_AV_CODEC_ID_SMV: AVCodecID = 88068;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF: AVCodecID = 88069;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF: AVCodecID = 88070;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 88071;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 88072;
pub const AVCodecID_AV_CODEC_ID_4GV: AVCodecID = 88073;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 88074;
pub const AVCodecID_AV_CODEC_ID_XMA1: AVCodecID = 88075;
pub const AVCodecID_AV_CODEC_ID_XMA2: AVCodecID = 88076;
pub const AVCodecID_AV_CODEC_ID_DST: AVCodecID = 88077;
pub const AVCodecID_AV_CODEC_ID_ATRAC3AL: AVCodecID = 88078;
pub const AVCodecID_AV_CODEC_ID_ATRAC3PAL: AVCodecID = 88079;
pub const AVCodecID_AV_CODEC_ID_DOLBY_E: AVCodecID = 88080;
pub const AVCodecID_AV_CODEC_ID_APTX: AVCodecID = 88081;
pub const AVCodecID_AV_CODEC_ID_APTX_HD: AVCodecID = 88082;
pub const AVCodecID_AV_CODEC_ID_SBC: AVCodecID = 88083;
pub const AVCodecID_AV_CODEC_ID_ATRAC9: AVCodecID = 88084;
///< A dummy ID pointing at the start of subtitle codecs.
pub const AVCodecID_AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
///< raw UTF-8 text
pub const AVCodecID_AV_CODEC_ID_TEXT: AVCodecID = 94210;
pub const AVCodecID_AV_CODEC_ID_XSUB: AVCodecID = 94211;
pub const AVCodecID_AV_CODEC_ID_SSA: AVCodecID = 94212;
pub const AVCodecID_AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
pub const AVCodecID_AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
pub const AVCodecID_AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
pub const AVCodecID_AV_CODEC_ID_SRT: AVCodecID = 94216;
pub const AVCodecID_AV_CODEC_ID_MICRODVD: AVCodecID = 96256;
pub const AVCodecID_AV_CODEC_ID_EIA_608: AVCodecID = 96257;
pub const AVCodecID_AV_CODEC_ID_JACOSUB: AVCodecID = 96258;
pub const AVCodecID_AV_CODEC_ID_SAMI: AVCodecID = 96259;
pub const AVCodecID_AV_CODEC_ID_REALTEXT: AVCodecID = 96260;
pub const AVCodecID_AV_CODEC_ID_STL: AVCodecID = 96261;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER1: AVCodecID = 96262;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER: AVCodecID = 96263;
pub const AVCodecID_AV_CODEC_ID_SUBRIP: AVCodecID = 96264;
pub const AVCodecID_AV_CODEC_ID_WEBVTT: AVCodecID = 96265;
pub const AVCodecID_AV_CODEC_ID_MPL2: AVCodecID = 96266;
pub const AVCodecID_AV_CODEC_ID_VPLAYER: AVCodecID = 96267;
pub const AVCodecID_AV_CODEC_ID_PJS: AVCodecID = 96268;
pub const AVCodecID_AV_CODEC_ID_ASS: AVCodecID = 96269;
pub const AVCodecID_AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 96270;
pub const AVCodecID_AV_CODEC_ID_TTML: AVCodecID = 96271;
///< A dummy ID pointing at the start of various fake codecs.
pub const AVCodecID_AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
pub const AVCodecID_AV_CODEC_ID_TTF: AVCodecID = 98304;
///< Contain timestamp estimated through PCR of program stream.
pub const AVCodecID_AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
pub const AVCodecID_AV_CODEC_ID_BINTEXT: AVCodecID = 100352;
pub const AVCodecID_AV_CODEC_ID_XBIN: AVCodecID = 100353;
pub const AVCodecID_AV_CODEC_ID_IDF: AVCodecID = 100354;
pub const AVCodecID_AV_CODEC_ID_OTF: AVCodecID = 100355;
pub const AVCodecID_AV_CODEC_ID_SMPTE_KLV: AVCodecID = 100356;
pub const AVCodecID_AV_CODEC_ID_DVD_NAV: AVCodecID = 100357;
pub const AVCodecID_AV_CODEC_ID_TIMED_ID3: AVCodecID = 100358;
pub const AVCodecID_AV_CODEC_ID_BIN_DATA: AVCodecID = 100359;
///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
pub const AVCodecID_AV_CODEC_ID_PROBE: AVCodecID = 102400;
///< _FAKE_ codec to indicate a raw MPEG-2 TS
/// stream (only used by libavformat)
pub const AVCodecID_AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
///< _FAKE_ codec to indicate a MPEG-4 Systems
/// stream (only used by libavformat)
pub const AVCodecID_AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
///< Dummy codec for streams containing only metadata information.
pub const AVCodecID_AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
///< Passthrough codec, AVFrames wrapped in AVPacket
pub const AVCodecID_AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
/// Identify the syntax and semantics of the bitstream.
/// The principle is roughly:
/// Two decoders with the same ID can decode the same streams.
/// Two encoders with the same ID can encode compatible streams.
/// There may be slight deviations from the principle due to implementation
/// details.
///
/// If you add a codec ID to this list, add it so that
/// 1. no value of an existing codec ID changes (that would break ABI),
/// 2. it is as close as possible to similar codecs
///
/// After adding new codec IDs, do not forget to add an entry to the codec
/// descriptor list and bump libavcodec minor version.
pub type AVCodecID = i32;
/// This struct describes the properties of a single codec described by an
/// AVCodecID.
/// @see avcodec_descriptor_get()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    /// Name of the codec described by this descriptor. It is non-empty and
    /// unique for each codec descriptor. It should contain alphanumeric
    /// characters and '_' only.
    pub name: *const ::std::os::raw::c_char,
    /// A more descriptive name for this codec. May be NULL.
    pub long_name: *const ::std::os::raw::c_char,
    /// Codec properties, a combination of AV_CODEC_PROP_* flags.
    pub props: ::std::os::raw::c_int,
    /// MIME type(s) associated with the codec.
    /// May be NULL; if not, a NULL-terminated array of MIME types.
    /// The first item is always non-NULL and is the preferred MIME type.
    pub mime_types: *const *const ::std::os::raw::c_char,
    /// If non-NULL, an array of profiles recognized for this codec.
    /// Terminated with FF_PROFILE_UNKNOWN.
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecDescriptor>(),
        48usize,
        concat!("Size of: ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).long_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).props as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).mime_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).profiles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(profiles)
        )
    );
}
///< discard nothing
pub const AVDiscard_AVDISCARD_NONE: AVDiscard = -16;
///< discard useless packets like 0 size packets in avi
pub const AVDiscard_AVDISCARD_DEFAULT: AVDiscard = 0;
///< discard all non reference
pub const AVDiscard_AVDISCARD_NONREF: AVDiscard = 8;
///< discard all bidirectional frames
pub const AVDiscard_AVDISCARD_BIDIR: AVDiscard = 16;
///< discard all non intra frames
pub const AVDiscard_AVDISCARD_NONINTRA: AVDiscard = 24;
///< discard all frames except keyframes
pub const AVDiscard_AVDISCARD_NONKEY: AVDiscard = 32;
///< discard all
pub const AVDiscard_AVDISCARD_ALL: AVDiscard = 48;
/// @ingroup lavc_decoding
pub type AVDiscard = i32;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
///< Not part of ABI
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
pub type AVAudioServiceType = i32;
/// @ingroup lavc_encoding
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RcOverride {
    pub start_frame: ::std::os::raw::c_int,
    pub end_frame: ::std::os::raw::c_int,
    pub qscale: ::std::os::raw::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    assert_eq!(
        ::std::mem::size_of::<RcOverride>(),
        16usize,
        concat!("Size of: ", stringify!(RcOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<RcOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(RcOverride))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).start_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).end_frame as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).qscale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(qscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).quality_factor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(quality_factor)
        )
    );
}
/// Pan Scan area.
/// This specifies the area which should be displayed.
/// Note there may be multiple such areas for one frame.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPanScan {
    /// id
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub id: ::std::os::raw::c_int,
    /// width and height in 1/16 pel
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    /// position of the top left corner in 1/16 pel for up to 3 fields/frames
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    assert_eq!(
        ::std::mem::size_of::<AVPanScan>(),
        24usize,
        concat!("Size of: ", stringify!(AVPanScan))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPanScan>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPanScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).position as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(position)
        )
    );
}
/// This structure describes the bitrate properties of an encoded bitstream. It
/// roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
/// parameters for H.264/HEVC.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCPBProperties {
    /// Maximum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub max_bitrate: ::std::os::raw::c_int,
    /// Minimum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub min_bitrate: ::std::os::raw::c_int,
    /// Average bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub avg_bitrate: ::std::os::raw::c_int,
    /// The size of the buffer to which the ratecontrol is applied, in bits.
    /// Zero if unknown or unspecified.
    pub buffer_size: ::std::os::raw::c_int,
    /// The delay between the time the packet this structure is associated with
    /// is received and the time when it should be decoded, in periods of a 27MHz
    /// clock.
    ///
    /// UINT64_MAX when unknown or unspecified.
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    assert_eq!(
        ::std::mem::size_of::<AVCPBProperties>(),
        24usize,
        concat!("Size of: ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCPBProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).max_bitrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(max_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).min_bitrate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(min_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).avg_bitrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(avg_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).buffer_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).vbv_delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(vbv_delay)
        )
    );
}
/// An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
/// bytes worth of palette. This side data signals that a new palette is
/// present.
pub const AVPacketSideDataType_AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
/// The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
/// that the extradata buffer was changed and the receiving side should
/// act upon it appropriately. The new extradata is embedded in the side
/// data buffer and should be immediately used for processing the current
/// frame or packet.
pub const AVPacketSideDataType_AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
/// An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
/// @code
/// u32le param_flags
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
///     s32le channel_count
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
///     u64le channel_layout
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
///     s32le sample_rate
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
///     s32le width
///     s32le height
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
/// An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
/// structures with info about macroblocks relevant to splitting the
/// packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
/// That is, it does not necessarily contain info about all macroblocks,
/// as long as the distance between macroblocks in the info is smaller
/// than the target payload size.
/// Each MB info structure is 12 bytes, and is laid out as follows:
/// @code
/// u32le bit offset from the start of the packet
/// u8    current quantizer at the start of the macroblock
/// u8    GOB number
/// u16le macroblock address within the GOB
/// u8    horizontal MV predictor
/// u8    vertical MV predictor
/// u8    horizontal MV predictor for block number 3
/// u8    vertical MV predictor for block number 3
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
/// This side data should be associated with an audio stream and contains
/// ReplayGain information in form of the AVReplayGain struct.
pub const AVPacketSideDataType_AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
/// This side data contains a 3x3 transformation matrix describing an affine
/// transformation that needs to be applied to the decoded video frames for
/// correct presentation.
///
/// See libavutil/display.h for a detailed description of the data.
pub const AVPacketSideDataType_AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
/// This side data should be associated with a video stream and contains
/// Stereoscopic 3D information in form of the AVStereo3D struct.
pub const AVPacketSideDataType_AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
/// This side data should be associated with an audio stream and corresponds
/// to enum AVAudioServiceType.
pub const AVPacketSideDataType_AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
/// This side data contains quality related information from the encoder.
/// @code
/// u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
/// u8    picture type
/// u8    error count
/// u16   reserved
/// u64le[error count] sum of squared differences between encoder in and output
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
/// This side data contains an integer value representing the stream index
/// of a "fallback" track.  A fallback track indicates an alternate
/// track to use when the current track can not be decoded for some reason.
/// e.g. no decoder available for codec.
pub const AVPacketSideDataType_AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
/// This side data corresponds to the AVCPBProperties struct.
pub const AVPacketSideDataType_AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
/// Recommmends skipping the specified number of samples
/// @code
/// u32le number of samples to skip from start of this packet
/// u32le number of samples to skip from end of this packet
/// u8    reason for start skip
/// u8    reason for end   skip (0=padding silence, 1=convergence)
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 11;
/// An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
/// the packet may contain "dual mono" audio specific to Japanese DTV
/// and if it is true, recommends only the selected channel to be used.
/// @code
/// u8    selected channels (0=mail/left, 1=sub/right, 2=both)
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 12;
/// A list of zero terminated key/value strings. There is no end marker for
/// the list, so it is required to rely on the side data size to stop.
pub const AVPacketSideDataType_AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 13;
/// Subtitle event position
/// @code
/// u32le x1
/// u32le y1
/// u32le x2
/// u32le y2
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 14;
/// Data found in BlockAdditional element of matroska container. There is
/// no end marker for the data, so it is required to rely on the side data
/// size to recognize the end. 8 byte id (as found in BlockAddId) followed
/// by data.
pub const AVPacketSideDataType_AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 15;
/// The optional first identifier line of a WebVTT cue.
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 16;
/// The optional settings (rendering instructions) that immediately
/// follow the timestamp specifier of a WebVTT cue.
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 17;
/// A list of zero terminated key/value strings. There is no end marker for
/// the list, so it is required to rely on the side data size to stop. This
/// side data includes updated metadata which appeared in the stream.
pub const AVPacketSideDataType_AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 18;
/// MPEGTS stream ID, this is required to pass the stream ID
/// information from the demuxer to the corresponding muxer.
pub const AVPacketSideDataType_AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 19;
/// Mastering display metadata (based on SMPTE-2086:2014). This metadata
/// should be associated with a video stream and contains data in the form
/// of the AVMasteringDisplayMetadata struct.
pub const AVPacketSideDataType_AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 20;
/// This side data should be associated with a video stream and corresponds
/// to the AVSphericalMapping structure.
pub const AVPacketSideDataType_AV_PKT_DATA_SPHERICAL: AVPacketSideDataType = 21;
/// Content light level (based on CTA-861.3). This metadata should be
/// associated with a video stream and contains data in the form of the
/// AVContentLightMetadata struct.
pub const AVPacketSideDataType_AV_PKT_DATA_CONTENT_LIGHT_LEVEL: AVPacketSideDataType = 22;
/// ATSC A53 Part 4 Closed Captions. This metadata should be associated with
/// a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
/// The number of bytes of CC data is AVPacketSideData.size.
pub const AVPacketSideDataType_AV_PKT_DATA_A53_CC: AVPacketSideDataType = 23;
/// This side data is encryption initialization data.
/// The format is not part of ABI, use av_encryption_init_info_* methods to
/// access.
pub const AVPacketSideDataType_AV_PKT_DATA_ENCRYPTION_INIT_INFO: AVPacketSideDataType = 24;
/// This side data contains encryption info for how to decrypt the packet.
/// The format is not part of ABI, use av_encryption_info_* methods to access.
pub const AVPacketSideDataType_AV_PKT_DATA_ENCRYPTION_INFO: AVPacketSideDataType = 25;
/// Active Format Description data consisting of a single byte as specified
/// in ETSI TS 101 154 using AVActiveFormatDescription enum.
pub const AVPacketSideDataType_AV_PKT_DATA_AFD: AVPacketSideDataType = 26;
/// The number of side data types.
/// This is not part of the public API/ABI in the sense that it may
/// change when new side data types are added.
/// This must stay the last enum value.
/// If its value becomes huge, some code using it
/// needs to be updated as it assumes it to be smaller than other limits.
pub const AVPacketSideDataType_AV_PKT_DATA_NB: AVPacketSideDataType = 27;
/// @defgroup lavc_packet AVPacket
///
/// Types and functions for working with AVPacket.
/// @{
pub type AVPacketSideDataType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVPacketSideData>(),
        16usize,
        concat!("Size of: ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(type_)
        )
    );
}
/// This structure stores compressed data. It is typically exported by demuxers
/// and then passed as input to decoders, or received as output from encoders and
/// then passed to muxers.
///
/// For video, it should typically contain one compressed frame. For audio it may
/// contain several compressed frames. Encoders are allowed to output empty
/// packets, with no compressed data, containing only side data
/// (e.g. to update some stream parameters at the end of encoding).
///
/// AVPacket is one of the few structs in FFmpeg, whose size is a part of public
/// ABI. Thus it may be allocated on stack and no new fields can be added to it
/// without libavcodec and libavformat major bump.
///
/// The semantics of data ownership depends on the buf field.
/// If it is set, the packet data is dynamically allocated and is
/// valid indefinitely until a call to av_packet_unref() reduces the
/// reference count to 0.
///
/// If the buf field is not set av_packet_ref() would make a copy instead
/// of increasing the reference count.
///
/// The side data is always allocated with av_malloc(), copied by
/// av_packet_ref() and freed by av_packet_unref().
///
/// @see av_packet_ref
/// @see av_packet_unref
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacket {
    /// A reference to the reference-counted buffer where the packet data is
    /// stored.
    /// May be NULL, then the packet data is not reference-counted.
    pub buf: *mut AVBufferRef,
    /// Presentation timestamp in AVStream->time_base units; the time at which
    /// the decompressed packet will be presented to the user.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    /// pts MUST be larger or equal to dts as presentation cannot happen before
    /// decompression, unless one wants to view hex dumps. Some formats misuse
    /// the terms dts and pts/cts to mean something different. Such timestamps
    /// must be converted to true pts/dts before they are stored in AVPacket.
    pub pts: i64,
    /// Decompression timestamp in AVStream->time_base units; the time at which
    /// the packet is decompressed.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    pub dts: i64,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub stream_index: ::std::os::raw::c_int,
    /// A combination of AV_PKT_FLAG values
    pub flags: ::std::os::raw::c_int,
    /// Additional packet data that can be provided by the container.
    /// Packet can contain several types of side information.
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: ::std::os::raw::c_int,
    /// Duration of this packet in AVStream->time_base units, 0 if unknown.
    /// Equals next_pts - this_pts in presentation order.
    pub duration: i64,
    ///< byte position in stream, -1 if unknown
    pub pos: i64,
    /// @deprecated Same as the duration field, but as int64_t. This was required
    /// for Matroska subtitles, whose duration values could overflow when the
    /// duration field was still an int.
    pub convergence_duration: i64,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    assert_eq!(
        ::std::mem::size_of::<AVPacket>(),
        88usize,
        concat!("Size of: ", stringify!(AVPacket))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacket>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).dts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).stream_index as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data_elems as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).duration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).convergence_duration as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(convergence_duration)
        )
    );
}
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT:
    AVSideDataParamChangeFlags = 1;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT:
    AVSideDataParamChangeFlags = 2;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE:
    AVSideDataParamChangeFlags = 4;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS:
    AVSideDataParamChangeFlags = 8;
pub type AVSideDataParamChangeFlags = i32;
/// @}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
pub const AVFieldOrder_AV_FIELD_UNKNOWN: AVFieldOrder = 0;
pub const AVFieldOrder_AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
pub const AVFieldOrder_AV_FIELD_TT: AVFieldOrder = 2;
pub const AVFieldOrder_AV_FIELD_BB: AVFieldOrder = 3;
pub const AVFieldOrder_AV_FIELD_TB: AVFieldOrder = 4;
pub const AVFieldOrder_AV_FIELD_BT: AVFieldOrder = 5;
pub type AVFieldOrder = i32;
/// main external API structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
/// applications.
/// The name string for AVOptions options matches the associated command line
/// parameter name and can be found in libavcodec/options_table.h
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
/// sizeof(AVCodecContext) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecContext {
    /// information on struct for av_log
    /// - set by avcodec_alloc_context3
    pub av_class: *const AVClass,
    pub log_level_offset: ::std::os::raw::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
    /// This is used to work around some encoder bugs.
    /// A demuxer should set this to what is stored in the field used to identify the codec.
    /// If there are multiple such fields in a container then the demuxer should choose the one
    /// which maximizes the information about the used codec.
    /// If the codec tag field in a container is larger than 32 bits then the demuxer should
    /// remap the longer ID to 32 bits with a table or other structure. Alternatively a new
    /// extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
    /// first.
    /// - encoding: Set by user, if not then the default based on codec_id will be used.
    /// - decoding: Set by user, will be converted to uppercase by libavcodec during init.
    pub codec_tag: ::std::os::raw::c_uint,
    pub priv_data: *mut ::std::os::raw::c_void,
    /// Private context used for internal data.
    ///
    /// Unlike priv_data, this is not codec-specific. It is used in general
    /// libavcodec functions.
    pub internal: *mut AVCodecInternal,
    /// Private data of the user, can be used to carry app specific stuff.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub opaque: *mut ::std::os::raw::c_void,
    /// the average bitrate
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: Set by user, may be overwritten by libavcodec
    ///             if this info is available in the stream
    pub bit_rate: i64,
    /// number of bits the bitstream is allowed to diverge from the reference.
    ///           the reference can be CBR (for CBR pass1) or VBR (for pass2)
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: unused
    pub bit_rate_tolerance: ::std::os::raw::c_int,
    /// Global quality for codecs which cannot change it per frame.
    /// This should be proportional to MPEG-1/2/4 qscale.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub global_quality: ::std::os::raw::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub compression_level: ::std::os::raw::c_int,
    /// AV_CODEC_FLAG_*.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags: ::std::os::raw::c_int,
    /// AV_CODEC_FLAG2_*
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags2: ::std::os::raw::c_int,
    /// some codecs need / can use extradata like Huffman tables.
    /// MJPEG: Huffman tables
    /// rv10: additional flags
    /// MPEG-4: global headers (they can be in the bitstream or here)
    /// The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
    /// than extradata_size to avoid problems if it is read with the bitstream reader.
    /// The bytewise contents of extradata must not depend on the architecture or CPU endianness.
    /// Must be allocated with the av_malloc() family of functions.
    /// - encoding: Set/allocated/freed by libavcodec.
    /// - decoding: Set/allocated/freed by user.
    pub extradata: *mut u8,
    pub extradata_size: ::std::os::raw::c_int,
    /// This is the fundamental unit of time (in seconds) in terms
    /// of which frame timestamps are represented. For fixed-fps content,
    /// timebase should be 1/framerate and timestamp increments should be
    /// identically 1.
    /// This often, but not always is the inverse of the frame rate or field rate
    /// for video. 1/time_base is not the average frame rate if the frame rate is not
    /// constant.
    ///
    /// Like containers, elementary streams also can store timestamps, 1/time_base
    /// is the unit in which these timestamps are specified.
    /// As example of such codec time base see ISO/IEC 14496-2:2001(E)
    /// vop_time_increment_resolution and fixed_vop_rate
    /// (fixed_vop_rate == 0 implies that it is different from the framerate)
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: the use of this field for decoding is deprecated.
    ///             Use framerate instead.
    pub time_base: AVRational,
    /// For some codecs, the time base is closer to the field rate than the frame rate.
    /// Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
    /// if no telecine is used ...
    ///
    /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
    pub ticks_per_frame: ::std::os::raw::c_int,
    /// Codec delay.
    ///
    /// Encoding: Number of frames delay there will be from the encoder input to
    ///           the decoder output. (we assume the decoder matches the spec)
    /// Decoding: Number of frames delay in addition to what a standard decoder
    ///           as specified in the spec would produce.
    ///
    /// Video:
    ///   Number of frames the decoded output will be delayed relative to the
    ///   encoded input.
    ///
    /// Audio:
    ///   For encoding, this field is unused (see initial_padding).
    ///
    ///   For decoding, this is the number of samples the decoder needs to
    ///   output before the decoder's output is valid. When seeking, you should
    ///   start decoding this many samples prior to your desired seek point.
    ///
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub delay: ::std::os::raw::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    ///             from the container. Some decoders will require the dimensions
    ///             to be set by the caller. During decoding, the decoder may
    ///             overwrite those values as required while parsing the data.
    pub width: ::std::os::raw::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    ///             from the container. Some decoders will require the dimensions
    ///             to be set by the caller. During decoding, the decoder may
    ///             overwrite those values as required while parsing the data.
    pub height: ::std::os::raw::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    ///             e.g. from the container. During decoding, the decoder may
    ///             overwrite those values as required while parsing the data.
    pub coded_width: ::std::os::raw::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    ///             e.g. from the container. During decoding, the decoder may
    ///             overwrite those values as required while parsing the data.
    pub coded_height: ::std::os::raw::c_int,
    /// the number of pictures in a group of pictures, or 0 for intra_only
    /// - encoding: Set by user.
    /// - decoding: unused
    pub gop_size: ::std::os::raw::c_int,
    /// Pixel format, see AV_PIX_FMT_xxx.
    /// May be set by the demuxer if known from headers.
    /// May be overridden by the decoder if it knows better.
    ///
    /// @note This field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: Set by user.
    /// - decoding: Set by user if known, overridden by libavcodec while
    ///             parsing the data.
    pub pix_fmt: AVPixelFormat,
    /// If non NULL, 'draw_horiz_band' is called by the libavcodec
    /// decoder to draw a horizontal band. It improves cache usage. Not
    /// all codecs can do that. You must check the codec capabilities
    /// beforehand.
    /// When multithreading is used, it may be called from multiple threads
    /// at the same time; threads might draw different parts of the same AVFrame,
    /// or multiple AVFrames, and there is no guarantee that slices will be drawn
    /// in order.
    /// The function is also used by hardware acceleration APIs.
    /// It is called at least once during frame decoding to pass
    /// the data needed for hardware render.
    /// In that mode instead of pixel data, AVFrame points to
    /// a structure specific to the acceleration API. The application
    /// reads the structure and can change some fields to indicate progress
    /// or mark state.
    /// - encoding: unused
    /// - decoding: Set by user.
    /// @param height the height of the slice
    /// @param y the y position of the slice
    /// @param type 1->top field, 2->bottom field, 3->frame
    /// @param offset offset into the AVFrame.data from which the slice should be read
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    /// callback to negotiate the pixelFormat
    /// @param fmt is the list of formats which are supported by the codec,
    /// it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
    /// The first is always the native one.
    /// @note The callback may be called again immediately if initialization for
    /// the selected (hardware-accelerated) pixel format failed.
    /// @warning Behavior is undefined if the callback returns a value not
    /// in the fmt list of formats.
    /// @return the chosen format
    /// - encoding: unused
    /// - decoding: Set by user, if not set the native format will be chosen.
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    /// maximum number of B-frames between non-B-frames
    /// Note: The output will be delayed by max_b_frames+1 relative to the input.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_b_frames: ::std::os::raw::c_int,
    /// qscale factor between IP and B-frames
    /// If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_factor: f32,
    /// @deprecated use encoder private options instead
    pub b_frame_strategy: ::std::os::raw::c_int,
    /// qscale offset between IP and B-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_offset: f32,
    /// Size of the frame reordering buffer in the decoder.
    /// For MPEG-2 it is 1 IPB or 0 low delay IP.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub has_b_frames: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub mpeg_quant: ::std::os::raw::c_int,
    /// qscale factor between P- and I-frames
    /// If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_factor: f32,
    /// qscale offset between P and I-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_offset: f32,
    /// luminance masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub lumi_masking: f32,
    /// temporary complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub temporal_cplx_masking: f32,
    /// spatial complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub spatial_cplx_masking: f32,
    /// p block masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub p_masking: f32,
    /// darkness masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dark_masking: f32,
    /// slice count
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user (or 0).
    pub slice_count: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub prediction_method: ::std::os::raw::c_int,
    /// slice offsets in the frame in bytes
    /// - encoding: Set/allocated by libavcodec.
    /// - decoding: Set/allocated by user (or NULL).
    pub slice_offset: *mut ::std::os::raw::c_int,
    /// sample aspect ratio (0 if unknown)
    /// That is the width of a pixel divided by the height of the pixel.
    /// Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub sample_aspect_ratio: AVRational,
    /// motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_cmp: ::std::os::raw::c_int,
    /// subpixel motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_sub_cmp: ::std::os::raw::c_int,
    /// macroblock comparison function (not supported yet)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_cmp: ::std::os::raw::c_int,
    /// interlaced DCT comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub ildct_cmp: ::std::os::raw::c_int,
    /// ME diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dia_size: ::std::os::raw::c_int,
    /// amount of previous MV predictors (2a+1 x 2a+1 square)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub last_predictor_count: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub pre_me: ::std::os::raw::c_int,
    /// motion estimation prepass comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_pre_cmp: ::std::os::raw::c_int,
    /// ME prepass diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub pre_dia_size: ::std::os::raw::c_int,
    /// subpel ME quality
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_subpel_quality: ::std::os::raw::c_int,
    /// maximum motion estimation search range in subpel units
    /// If 0 then no limit.
    ///
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_range: ::std::os::raw::c_int,
    /// slice flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub slice_flags: ::std::os::raw::c_int,
    /// macroblock decision mode
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_decision: ::std::os::raw::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub intra_matrix: *mut u16,
    /// custom inter quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub inter_matrix: *mut u16,
    /// @deprecated use encoder private options instead
    pub scenechange_threshold: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub noise_reduction: ::std::os::raw::c_int,
    /// precision of the intra DC coefficient - 8
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec
    pub intra_dc_precision: ::std::os::raw::c_int,
    /// Number of macroblock rows at the top which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_top: ::std::os::raw::c_int,
    /// Number of macroblock rows at the bottom which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_bottom: ::std::os::raw::c_int,
    /// minimum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmin: ::std::os::raw::c_int,
    /// maximum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmax: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub me_penalty_compensation: ::std::os::raw::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub bidir_refine: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub brd_scale: ::std::os::raw::c_int,
    /// minimum GOP size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub keyint_min: ::std::os::raw::c_int,
    /// number of reference frames
    /// - encoding: Set by user.
    /// - decoding: Set by lavc.
    pub refs: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub chromaoffset: ::std::os::raw::c_int,
    /// Note: Value depends upon the compare function used for fullpel ME.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mv0_threshold: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub b_sensitivity: ::std::os::raw::c_int,
    /// Chromaticity coordinates of the source primaries.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_primaries: AVColorPrimaries,
    /// Color Transfer Characteristic.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_trc: AVColorTransferCharacteristic,
    /// YUV colorspace type.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub colorspace: AVColorSpace,
    /// MPEG vs JPEG YUV range.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_range: AVColorRange,
    /// This defines the location of chroma samples.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub chroma_sample_location: AVChromaLocation,
    /// Number of slices.
    /// Indicates number of picture subdivisions. Used for parallelized
    /// decoding.
    /// - encoding: Set by user
    /// - decoding: unused
    pub slices: ::std::os::raw::c_int,
    /// Field order
    /// - encoding: set by libavcodec
    /// - decoding: Set by user.
    pub field_order: AVFieldOrder,
    ///< samples per second
    pub sample_rate: ::std::os::raw::c_int,
    ///< number of audio channels
    pub channels: ::std::os::raw::c_int,
    ///< sample format
    pub sample_fmt: AVSampleFormat,
    /// Number of samples per channel in an audio frame.
    ///
    /// - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
    ///   except the last must contain exactly frame_size samples per channel.
    ///   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
    ///   frame size is not restricted.
    /// - decoding: may be set by some decoders to indicate constant frame size
    pub frame_size: ::std::os::raw::c_int,
    /// Frame counter, set by libavcodec.
    ///
    /// - decoding: total number of frames returned from the decoder so far.
    /// - encoding: total number of frames passed to the encoder so far.
    ///
    ///   @note the counter is not incremented if encoding/decoding resulted in
    ///   an error.
    pub frame_number: ::std::os::raw::c_int,
    /// number of bytes per packet if constant and known or 0
    /// Used by some WAV based audio codecs.
    pub block_align: ::std::os::raw::c_int,
    /// Audio cutoff bandwidth (0 means "automatic")
    /// - encoding: Set by user.
    /// - decoding: unused
    pub cutoff: ::std::os::raw::c_int,
    /// Audio channel layout.
    /// - encoding: set by user.
    /// - decoding: set by user, may be overwritten by libavcodec.
    pub channel_layout: u64,
    /// Request decoder to use this channel layout if it can (0 for default)
    /// - encoding: unused
    /// - decoding: Set by user.
    pub request_channel_layout: u64,
    /// Type of service that the audio stream conveys.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub audio_service_type: AVAudioServiceType,
    /// desired sample format
    /// - encoding: Not used.
    /// - decoding: Set by user.
    /// Decoder will decode to this format if it can.
    pub request_sample_fmt: AVSampleFormat,
    /// This callback is called at the beginning of each frame to get data
    /// buffer(s) for it. There may be one contiguous buffer for all the data or
    /// there may be a buffer per each data plane or anything in between. What
    /// this means is, you may set however many entries in buf[] you feel necessary.
    /// Each buffer must be reference-counted using the AVBuffer API (see description
    /// of buf[] below).
    ///
    /// The following fields will be set in the frame before this callback is
    /// called:
    /// - format
    /// - width, height (video only)
    /// - sample_rate, channel_layout, nb_samples (audio only)
    /// Their values may differ from the corresponding values in
    /// AVCodecContext. This callback must use the frame values, not the codec
    /// context values, to calculate the required buffer size.
    ///
    /// This callback must fill the following fields in the frame:
    /// - data[]
    /// - linesize[]
    /// - extended_data:
    ///   * if the data is planar audio with more than 8 channels, then this
    ///     callback must allocate and fill extended_data to contain all pointers
    ///     to all data planes. data[] must hold as many pointers as it can.
    ///     extended_data must be allocated with av_malloc() and will be freed in
    ///     av_frame_unref().
    ///   * otherwise extended_data must point to data
    /// - buf[] must contain one or more pointers to AVBufferRef structures. Each of
    ///   the frame's data and extended_data pointers must be contained in these. That
    ///   is, one AVBufferRef for each allocated chunk of memory, not necessarily one
    ///   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
    ///   and av_buffer_ref().
    /// - extended_buf and nb_extended_buf must be allocated with av_malloc() by
    ///   this callback and filled with the extra buffers if there are more
    ///   buffers than buf[] can hold. extended_buf will be freed in
    ///   av_frame_unref().
    ///
    /// If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
    /// avcodec_default_get_buffer2() instead of providing buffers allocated by
    /// some other means.
    ///
    /// Each data plane must be aligned to the maximum required by the target
    /// CPU.
    ///
    /// @see avcodec_default_get_buffer2()
    ///
    /// Video:
    ///
    /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
    /// (read and/or written to if it is writable) later by libavcodec.
    ///
    /// avcodec_align_dimensions2() should be used to find the required width and
    /// height, as they normally need to be rounded up to the next multiple of 16.
    ///
    /// Some decoders do not support linesizes changing between frames.
    ///
    /// If frame multithreading is used and thread_safe_callbacks is set,
    /// this callback may be called from a different thread, but not from more
    /// than one at once. Does not need to be reentrant.
    ///
    /// @see avcodec_align_dimensions2()
    ///
    /// Audio:
    ///
    /// Decoders request a buffer of a particular size by setting
    /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
    /// however, utilize only part of the buffer by setting AVFrame.nb_samples
    /// to a smaller value in the output frame.
    ///
    /// As a convenience, av_samples_get_buffer_size() and
    /// av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
    /// functions to find the required data size and to fill data pointers and
    /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
    /// since all planes must be the same size.
    ///
    /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec, user can override.
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    /// If non-zero, the decoded audio and video frames returned from
    /// avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
    /// and are valid indefinitely. The caller must free them with
    /// av_frame_unref() when they are not needed anymore.
    /// Otherwise, the decoded frames must not be freed by the caller and are
    /// only valid until the next decode call.
    ///
    /// This is always automatically enabled if avcodec_receive_frame() is used.
    ///
    /// - encoding: unused
    /// - decoding: set by the caller before avcodec_open2().
    pub refcounted_frames: ::std::os::raw::c_int,
    ///< amount of qscale change between easy & hard scenes (0.0-1.0)
    pub qcompress: f32,
    ///< amount of qscale smoothing over time (0.0-1.0)
    pub qblur: f32,
    /// minimum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmin: ::std::os::raw::c_int,
    /// maximum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmax: ::std::os::raw::c_int,
    /// maximum quantizer difference between frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_qdiff: ::std::os::raw::c_int,
    /// decoder bitstream buffer size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_buffer_size: ::std::os::raw::c_int,
    /// ratecontrol override, see RcOverride
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub rc_override_count: ::std::os::raw::c_int,
    pub rc_override: *mut RcOverride,
    /// maximum bitrate
    /// - encoding: Set by user.
    /// - decoding: Set by user, may be overwritten by libavcodec.
    pub rc_max_rate: i64,
    /// minimum bitrate
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_min_rate: i64,
    /// Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_max_available_vbv_use: f32,
    /// Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_min_vbv_overflow_use: f32,
    /// Number of bits which should be loaded into the rc buffer before decoding starts.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_initial_buffer_occupancy: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub coder_type: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub context_model: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_threshold: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_factor: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_exp: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_cmp: ::std::os::raw::c_int,
    /// trellis RD quantization
    /// - encoding: Set by user.
    /// - decoding: unused
    pub trellis: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub min_prediction_order: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub max_prediction_order: ::std::os::raw::c_int,
    /// @deprecated use encoder private options instead
    pub timecode_frame_start: i64,
    /// @deprecated unused
    pub rtp_callback: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            data: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            mb_nb: ::std::os::raw::c_int,
        ),
    >,
    /// @deprecated use encoder private options instead
    pub rtp_payload_size: ::std::os::raw::c_int,
    pub mv_bits: ::std::os::raw::c_int,
    pub header_bits: ::std::os::raw::c_int,
    pub i_tex_bits: ::std::os::raw::c_int,
    pub p_tex_bits: ::std::os::raw::c_int,
    pub i_count: ::std::os::raw::c_int,
    pub p_count: ::std::os::raw::c_int,
    pub skip_count: ::std::os::raw::c_int,
    pub misc_bits: ::std::os::raw::c_int,
    /// @deprecated this field is unused
    pub frame_bits: ::std::os::raw::c_int,
    /// pass1 encoding statistics output buffer
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    pub stats_out: *mut ::std::os::raw::c_char,
    /// pass2 encoding statistics input buffer
    /// Concatenated stuff from stats_out of pass1 should be placed here.
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub stats_in: *mut ::std::os::raw::c_char,
    /// Work around bugs in encoders which sometimes cannot be detected automatically.
    /// - encoding: Set by user
    /// - decoding: Set by user
    pub workaround_bugs: ::std::os::raw::c_int,
    /// strictly follow the standard (MPEG-4, ...).
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    /// Setting this to STRICT or higher means the encoder and decoder will
    /// generally do stupid things, whereas setting it to unofficial or lower
    /// will mean the encoder might produce output that is not supported by all
    /// spec-compliant decoders. Decoders don't differentiate between normal,
    /// unofficial and experimental (that is, they always try to decode things
    /// when they can) unless they are explicitly asked to behave stupidly
    /// (=strictly conform to the specs)
    pub strict_std_compliance: ::std::os::raw::c_int,
    /// error concealment flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub error_concealment: ::std::os::raw::c_int,
    /// debug
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug: ::std::os::raw::c_int,
    /// Error recognition; may misdetect some more or less valid parts as errors.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub err_recognition: ::std::os::raw::c_int,
    /// opaque 64-bit number (generally a PTS) that will be reordered and
    /// output in AVFrame.reordered_opaque
    /// - encoding: Set by libavcodec to the reordered_opaque of the input
    ///             frame corresponding to the last returned packet. Only
    ///             supported by encoders with the
    ///             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.
    /// - decoding: Set by user.
    pub reordered_opaque: i64,
    /// Hardware accelerator in use
    /// - encoding: unused.
    /// - decoding: Set by libavcodec
    pub hwaccel: *const AVHWAccel,
    /// Hardware accelerator context.
    /// For some hardware accelerators, a global context needs to be
    /// provided by the user. In that case, this holds display-dependent
    /// data FFmpeg cannot instantiate itself. Please refer to the
    /// FFmpeg HW accelerator documentation to know how to fill this
    /// is. e.g. for VA API, this is a struct vaapi_context.
    /// - encoding: unused
    /// - decoding: Set by user
    pub hwaccel_context: *mut ::std::os::raw::c_void,
    /// error
    /// - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
    /// - decoding: unused
    pub error: [u64; 8usize],
    /// DCT algorithm, see FF_DCT_* below
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dct_algo: ::std::os::raw::c_int,
    /// IDCT algorithm, see FF_IDCT_* below.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub idct_algo: ::std::os::raw::c_int,
    /// bits per sample/pixel from the demuxer (needed for huffyuv).
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user.
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    /// Bits per sample/pixel of internal libavcodec pixel/sample format.
    /// - encoding: set by user.
    /// - decoding: set by libavcodec.
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
    /// - encoding: unused
    /// - decoding: Set by user.
    pub lowres: ::std::os::raw::c_int,
    /// the picture in the bitstream
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    ///
    /// @deprecated use the quality factor packet side data instead
    pub coded_frame: *mut AVFrame,
    /// thread count
    /// is used to decide how many independent tasks should be passed to execute()
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_count: ::std::os::raw::c_int,
    /// Which multithreading methods to use.
    /// Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
    /// so clients which cannot provide future frames should not use it.
    ///
    /// - encoding: Set by user, otherwise the default is used.
    /// - decoding: Set by user, otherwise the default is used.
    pub thread_type: ::std::os::raw::c_int,
    /// Which multithreading methods are in use by the codec.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub active_thread_type: ::std::os::raw::c_int,
    /// Set by the client if its custom get_buffer() callback can be called
    /// synchronously from another thread, which allows faster multithreaded decoding.
    /// draw_horiz_band() will be called from other threads regardless of this setting.
    /// Ignored if the default get_buffer() is used.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_safe_callbacks: ::std::os::raw::c_int,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// @param count the number of things to execute
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(c2: *mut AVCodecContext, arg: *mut ::std::os::raw::c_void)
                    -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
    /// @param c context passed also to func
    /// @param count the number of things to execute
    /// @param arg2 argument passed unchanged to func
    /// @param ret return values of executed functions, must have space for "count" values. May be NULL.
    /// @param func function that will be called count times, with jobnr from 0 to count-1.
    ///             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
    ///             two instances of func executing at the same time will have the same threadnr.
    /// @return always 0 currently, but code should handle a future improvement where when any call to func
    ///         returns < 0 no further calls to func may be done and < 0 is returned.
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                    jobnr: ::std::os::raw::c_int,
                    threadnr: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    /// noise vs. sse weight for the nsse comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub nsse_weight: ::std::os::raw::c_int,
    /// profile
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub profile: ::std::os::raw::c_int,
    /// level
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub level: ::std::os::raw::c_int,
    /// Skip loop filtering for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_loop_filter: AVDiscard,
    /// Skip IDCT/dequantization for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_idct: AVDiscard,
    /// Skip decoding for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_frame: AVDiscard,
    /// Header containing style information for text subtitles.
    /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
    /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
    /// the Format line following. It shouldn't include any Dialogue line.
    /// - encoding: Set/allocated/freed by user (before avcodec_open2())
    /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: ::std::os::raw::c_int,
    /// VBV delay coded in the last frame (in periods of a 27 MHz clock).
    /// Used for compliant TS muxing.
    /// - encoding: Set by libavcodec.
    /// - decoding: unused.
    /// @deprecated this value is now exported as a part of
    /// AV_PKT_DATA_CPB_PROPERTIES packet side data
    pub vbv_delay: u64,
    /// Encoding only and set by default. Allow encoders to output packets
    /// that do not contain any encoded data, only side data.
    ///
    /// Some encoders need to output such packets, e.g. to update some stream
    /// parameters at the end of encoding.
    ///
    /// @deprecated this field disables the default behaviour and
    ///             it is kept only for compatibility.
    pub side_data_only_packets: ::std::os::raw::c_int,
    /// Audio only. The number of "priming" samples (padding) inserted by the
    /// encoder at the beginning of the audio. I.e. this number of leading
    /// decoded samples must be discarded by the caller to get the original audio
    /// without leading padding.
    ///
    /// - decoding: unused
    /// - encoding: Set by libavcodec. The timestamps on the output packets are
    ///             adjusted by the encoder so that they always refer to the
    ///             first sample of the data actually contained in the packet,
    ///             including any added padding.  E.g. if the timebase is
    ///             1/samplerate and the timestamp of the first input sample is
    ///             0, the timestamp of the first output packet will be
    ///             -initial_padding.
    pub initial_padding: ::std::os::raw::c_int,
    /// - decoding: For codecs that store a framerate value in the compressed
    ///             bitstream, the decoder may export it here. { 0, 1} when
    ///             unknown.
    /// - encoding: May be used to signal the framerate of CFR content to an
    ///             encoder.
    pub framerate: AVRational,
    /// Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
    /// - encoding: unused.
    /// - decoding: Set by libavcodec before calling get_format()
    pub sw_pix_fmt: AVPixelFormat,
    /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
    /// - encoding unused.
    /// - decoding set by user.
    pub pkt_timebase: AVRational,
    /// AVCodecDescriptor
    /// - encoding: unused.
    /// - decoding: set by libavcodec.
    pub codec_descriptor: *const AVCodecDescriptor,
    /// Current statistics for PTS correction.
    /// - decoding: maintained and used by libavcodec, not intended to be used by user apps
    /// - encoding: unused
    pub pts_correction_num_faulty_pts: i64,
    /// Number of incorrect PTS values so far
    pub pts_correction_num_faulty_dts: i64,
    /// Number of incorrect DTS values so far
    pub pts_correction_last_pts: i64,
    /// PTS of the last frame
    pub pts_correction_last_dts: i64,
    /// Character encoding of the input subtitles file.
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_charenc: *mut ::std::os::raw::c_char,
    /// Subtitles character encoding mode. Formats or codecs might be adjusting
    /// this setting (if they are doing the conversion themselves for instance).
    /// - decoding: set by libavcodec
    /// - encoding: unused
    pub sub_charenc_mode: ::std::os::raw::c_int,
    /// Skip processing alpha if supported by codec.
    /// Note that if the format uses pre-multiplied alpha (common with VP6,
    /// and recommended due to better video quality/compression)
    /// the image will look as if alpha-blended onto a black background.
    /// However for formats that do not use pre-multiplied alpha
    /// there might be serious artefacts (though e.g. libswscale currently
    /// assumes pre-multiplied alpha anyway).
    ///
    /// - decoding: set by user
    /// - encoding: unused
    pub skip_alpha: ::std::os::raw::c_int,
    /// Number of samples to skip after a discontinuity
    /// - decoding: unused
    /// - encoding: set by libavcodec
    pub seek_preroll: ::std::os::raw::c_int,
    /// debug motion vectors
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug_mv: ::std::os::raw::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: unused.
    pub chroma_intra_matrix: *mut u16,
    /// dump format separator.
    /// can be ", " or "\n      " or anything else
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub dump_separator: *mut u8,
    /// ',' separated list of allowed decoders.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    /// Properties of the stream that gets decoded
    /// - encoding: unused
    /// - decoding: set by libavcodec
    pub properties: ::std::os::raw::c_uint,
    /// Additional data associated with the entire coded stream.
    ///
    /// - decoding: unused
    /// - encoding: may be set by libavcodec after avcodec_open2().
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: ::std::os::raw::c_int,
    /// A reference to the AVHWFramesContext describing the input (for encoding)
    /// or output (decoding) frames. The reference is set by the caller and
    /// afterwards owned (and freed) by libavcodec - it should never be read by
    /// the caller after being set.
    ///
    /// - decoding: This field should be set by the caller from the get_format()
    ///             callback. The previous reference (if any) will always be
    ///             unreffed by libavcodec before the get_format() call.
    ///
    ///             If the default get_buffer2() is used with a hwaccel pixel
    ///             format, then this AVHWFramesContext will be used for
    ///             allocating the frame buffers.
    ///
    /// - encoding: For hardware encoders configured to use a hwaccel pixel
    ///             format, this field should be set by the caller to a reference
    ///             to the AVHWFramesContext describing input frames.
    ///             AVHWFramesContext.format must be equal to
    ///             AVCodecContext.pix_fmt.
    ///
    ///             This field should be set before avcodec_open2() is called.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// Control the form of AVSubtitle.rects[N]->ass
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_text_format: ::std::os::raw::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    ///
    /// - decoding: unused
    /// - encoding: unused
    pub trailing_padding: ::std::os::raw::c_int,
    /// The number of pixels per image to maximally accept.
    ///
    /// - decoding: set by user
    /// - encoding: set by user
    pub max_pixels: i64,
    /// A reference to the AVHWDeviceContext describing the device which will
    /// be used by a hardware encoder/decoder.  The reference is set by the
    /// caller and afterwards owned (and freed) by libavcodec.
    ///
    /// This should be used if either the codec device does not require
    /// hardware frames or any that are used are to be allocated internally by
    /// libavcodec.  If the user wishes to supply any of the frames used as
    /// encoder input or decoder output then hw_frames_ctx should be used
    /// instead.  When hw_frames_ctx is set in get_format() for a decoder, this
    /// field will be ignored while decoding the associated stream segment, but
    /// may again be used on a following one after another get_format() call.
    ///
    /// For both encoders and decoders this field should be set before
    /// avcodec_open2() is called and must not be written to thereafter.
    ///
    /// Note that some decoders may require this field to be set initially in
    /// order to support hw_frames_ctx at all - in that case, all frames
    /// contexts used must be created on the same device.
    pub hw_device_ctx: *mut AVBufferRef,
    /// Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
    /// decoding (if active).
    /// - encoding: unused
    /// - decoding: Set by user (either before avcodec_open2(), or in the
    ///             AVCodecContext.get_format callback)
    pub hwaccel_flags: ::std::os::raw::c_int,
    /// Video decoding only. Certain video codecs support cropping, meaning that
    /// only a sub-rectangle of the decoded frame is intended for display.  This
    /// option controls how cropping is handled by libavcodec.
    ///
    /// When set to 1 (the default), libavcodec will apply cropping internally.
    /// I.e. it will modify the output frame width/height fields and offset the
    /// data pointers (only by as much as possible while preserving alignment, or
    /// by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
    /// the frames output by the decoder refer only to the cropped area. The
    /// crop_* fields of the output frames will be zero.
    ///
    /// When set to 0, the width/height fields of the output frames will be set
    /// to the coded dimensions and the crop_* fields will describe the cropping
    /// rectangle. Applying the cropping is left to the caller.
    ///
    /// @warning When hardware acceleration with opaque output frames is used,
    /// libavcodec is unable to apply cropping from the top/left border.
    ///
    /// @note when this option is set to zero, the width/height fields of the
    /// AVCodecContext and output AVFrames have different meanings. The codec
    /// context fields store display dimensions (with the coded dimensions in
    /// coded_width/height), while the frame fields store the coded dimensions
    /// (with the display dimensions being determined by the crop_* fields).
    pub apply_cropping: ::std::os::raw::c_int,
    pub extra_hw_frames: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecContext>(),
        1056usize,
        concat!("Size of: ", stringify!(AVCodecContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).log_level_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(log_level_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_tag as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).priv_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).internal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bit_rate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bit_rate_tolerance as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).global_quality as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(global_quality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).compression_level as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(compression_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags2 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).time_base as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ticks_per_frame as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ticks_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).delay as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).width as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_width as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_height as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).gop_size as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(gop_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pix_fmt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).draw_horiz_band as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(draw_horiz_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_format as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_b_frames as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_factor as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_frame_strategy as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_frame_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_offset as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).has_b_frames as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(has_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mpeg_quant as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mpeg_quant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_factor as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_offset as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lumi_masking as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lumi_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).temporal_cplx_masking as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(temporal_cplx_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).spatial_cplx_masking as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(spatial_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_masking as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dark_masking as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dark_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_count as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).prediction_method as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(prediction_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_offset as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).sample_aspect_ratio as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_cmp as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_sub_cmp as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_sub_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_cmp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ildct_cmp as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ildct_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dia_size as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).last_predictor_count as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(last_predictor_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pre_me as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_pre_cmp as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_pre_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pre_dia_size as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).me_subpel_quality as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_subpel_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_range as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_flags as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_decision as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_decision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).intra_matrix as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).inter_matrix as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).scenechange_threshold as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(scenechange_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).noise_reduction as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(noise_reduction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).intra_dc_precision as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_top as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_bottom as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmin as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmax as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).me_penalty_compensation as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_penalty_compensation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bidir_refine as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bidir_refine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).brd_scale as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(brd_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).keyint_min as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(keyint_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).refs as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).chromaoffset as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chromaoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mv0_threshold as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv0_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_sensitivity as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_sensitivity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_primaries as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_trc as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).colorspace as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_range as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_sample_location as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_sample_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slices as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).field_order as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_rate as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channels as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_fmt as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_size as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_number as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).block_align as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).cutoff as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channel_layout as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_channel_layout as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).audio_service_type as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(audio_service_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_sample_fmt as *const _ as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_buffer2 as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_buffer2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).refcounted_frames as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refcounted_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qcompress as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qcompress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qblur as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qblur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmin as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmax as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_qdiff as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_qdiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_buffer_size as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_override_count as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_override as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_max_rate as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_min_rate as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_max_available_vbv_use as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_available_vbv_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_min_vbv_overflow_use as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_vbv_overflow_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_initial_buffer_occupancy as *const _
                as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_buffer_occupancy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coder_type as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coder_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).context_model as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(context_model)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_threshold as *const _ as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_factor as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_exp as *const _ as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_cmp as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trellis as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trellis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).min_prediction_order as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(min_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).max_prediction_order as *const _ as usize
        },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).timecode_frame_start as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(timecode_frame_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rtp_callback as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rtp_payload_size as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mv_bits as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).header_bits as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(header_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_tex_bits as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_tex_bits as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_count as *const _ as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_count as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_count as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).misc_bits as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(misc_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_bits as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_out as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_in as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).workaround_bugs as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(workaround_bugs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).strict_std_compliance as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).error_concealment as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_concealment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).err_recognition as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(err_recognition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).reordered_opaque as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_context as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).error as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dct_algo as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).idct_algo as *const _ as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_coded_sample as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_raw_sample as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lowres as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_frame as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_count as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_type as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).active_thread_type as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(active_thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).thread_safe_callbacks as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_safe_callbacks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute2 as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).nsse_weight as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nsse_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).profile as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).level as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_loop_filter as *const _ as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_loop_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_idct as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_idct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_frame as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header_size as *const _ as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).vbv_delay as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(vbv_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).side_data_only_packets as *const _ as usize
        },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(side_data_only_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).initial_padding as *const _ as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).framerate as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sw_pix_fmt as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sw_pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pkt_timebase as *const _ as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pkt_timebase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_descriptor as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_pts as *const _
                as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_dts as *const _
                as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_pts as *const _ as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_dts as *const _ as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc_mode as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_alpha as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).seek_preroll as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug_mv as *const _ as usize },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug_mv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_intra_matrix as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dump_separator as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_whitelist as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).properties as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_side_data as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).nb_coded_side_data as *const _ as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_frames_ctx as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_text_format as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_text_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trailing_padding as *const _ as usize },
        1020usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_pixels as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_device_ctx as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_flags as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).apply_cropping as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(apply_cropping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extra_hw_frames as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
}
extern "C" {
    /// Accessors for some AVCodecContext fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext) -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext, val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(
        avctx: *mut AVCodecContext,
        desc: *const AVCodecDescriptor,
    );
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext) -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext, val: *mut u16);
}
/// AVProfile.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProfile {
    pub profile: ::std::os::raw::c_int,
    ///< short name for the profile
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    assert_eq!(
        ::std::mem::size_of::<AVProfile>(),
        16usize,
        concat!("Size of: ", stringify!(AVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(name)
        )
    );
}
/// The codec supports this format via the hw_device_ctx interface.
///
/// When selecting this format, AVCodecContext.hw_device_ctx should
/// have been set to a device of the specified type before calling
/// avcodec_open2().
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_3 = 1;
/// The codec supports this format via the hw_frames_ctx interface.
///
/// When selecting this format for a decoder,
/// AVCodecContext.hw_frames_ctx should be set to a suitable frames
/// context inside the get_format() callback.  The frames context
/// must have been created on a device of the specified type.
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_3 = 2;
/// The codec supports this format by some internal method.
///
/// This format can be selected without any additional configuration -
/// no device or frames context is required.
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_3 = 4;
/// The codec supports this format by some ad-hoc method.
///
/// Additional settings and/or function calls are required.  See the
/// codec-specific documentation for details.  (Methods requiring
/// this sort of configuration are deprecated and others should be
/// used in preference.)
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfig {
    /// A hardware pixel format which the codec can use.
    pub pix_fmt: AVPixelFormat,
    /// Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
    /// setup methods which can be used with this configuration.
    pub methods: ::std::os::raw::c_int,
    /// The device type associated with the configuration.
    ///
    /// Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
    /// AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
    pub device_type: AVHWDeviceType,
}
#[test]
fn bindgen_test_layout_AVCodecHWConfig() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecHWConfig>(),
        12usize,
        concat!("Size of: ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecHWConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).pix_fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).methods as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).device_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(device_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
/// AVCodec.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodec {
    /// Name of the codec implementation.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    /// This is the primary way to find a codec from the user perspective.
    pub name: *const ::std::os::raw::c_char,
    /// Descriptive name for the codec, meant to be more human readable than name.
    /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
    pub long_name: *const ::std::os::raw::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    /// Codec capabilities.
    /// see AV_CODEC_CAP_*
    pub capabilities: ::std::os::raw::c_int,
    ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
    pub supported_framerates: *const AVRational,
    ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
    pub pix_fmts: *const AVPixelFormat,
    ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
    pub supported_samplerates: *const ::std::os::raw::c_int,
    ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
    pub sample_fmts: *const AVSampleFormat,
    ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
    pub channel_layouts: *const u64,
    ///< maximum value for lowres supported by the decoder
    pub max_lowres: u8,
    ///< AVClass for the private context
    pub priv_class: *const AVClass,
    ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
    pub profiles: *const AVProfile,
    /// Group name of the codec implementation.
    /// This is a short symbolic name of the wrapper backing this codec. A
    /// wrapper uses some kind of external implementation for the codec, such
    /// as an external library, or a codec implementation provided by the OS or
    /// the hardware.
    /// If this field is NULL, this is a builtin, libavcodec native codec.
    /// If non-NULL, this will be the suffix in AVCodec.name in most cases
    /// (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
    pub wrapper_name: *const ::std::os::raw::c_char,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: ::std::os::raw::c_int,
    pub next: *mut AVCodec,
    /// @name Frame-level threading support functions
    /// @{
    ////
    ////**
    /// If defined, called on thread contexts when they are created.
    /// If the codec allocates writable tables in init(), re-allocate them here.
    /// priv_data will be set to a copy of the original.
    pub init_thread_copy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    /// Copy necessary context variables from a previous thread context to the current one.
    /// If not defined, the next thread will start automatically; otherwise, the codec
    /// must call ff_thread_finish_setup().
    ///
    /// dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
    pub update_thread_context: ::std::option::Option<
        unsafe extern "C" fn(dst: *mut AVCodecContext, src: *const AVCodecContext)
            -> ::std::os::raw::c_int,
    >,
    /// Private codec-specific defaults.
    pub defaults: *const AVCodecDefault,
    /// Initialize codec static data, called from avcodec_register().
    ///
    /// This is not intended for time consuming operations as it is
    /// run for every codec regardless of that codec being used.
    pub init_static_data: ::std::option::Option<unsafe extern "C" fn(codec: *mut AVCodec)>,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub encode_sub: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
            sub: *const AVSubtitle,
        ) -> ::std::os::raw::c_int,
    >,
    /// Encode data to an AVPacket.
    ///
    /// @param      avctx          codec context
    /// @param      avpkt          output AVPacket (may contain a user-provided buffer)
    /// @param[in]  frame          AVFrame containing the raw data to be encoded
    /// @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
    ///                            non-empty packet was returned in avpkt.
    /// @return 0 on success, negative error code on failure
    pub encode2: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
            frame: *const AVFrame,
            got_packet_ptr: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            outdata: *mut ::std::os::raw::c_void,
            outdata_size: *mut ::std::os::raw::c_int,
            avpkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    /// Encode API with decoupled packet/frame dataflow. The API is the
    /// same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except
    /// that:
    /// - never called if the codec is closed or the wrong type,
    /// - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent,
    /// - only one drain frame is ever passed down,
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *const AVFrame)
            -> ::std::os::raw::c_int,
    >,
    pub receive_packet: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, avpkt: *mut AVPacket)
            -> ::std::os::raw::c_int,
    >,
    /// Decode API with decoupled packet/frame dataflow. This function is called
    /// to get one output frame. It should call ff_decode_get_packet() to obtain
    /// input data.
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame)
            -> ::std::os::raw::c_int,
    >,
    /// Flush buffers.
    /// Will be called when seeking
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext)>,
    /// Internal codec capabilities.
    /// See FF_CODEC_CAP_* in internal.h
    pub caps_internal: ::std::os::raw::c_int,
    /// Decoding only, a comma-separated list of bitstream filters to apply to
    /// packets before decoding.
    pub bsfs: *const ::std::os::raw::c_char,
    /// Array of pointers to hardware configurations supported by the codec,
    /// or NULL if no hardware supported.  The array is terminated by a NULL
    /// pointer.
    ///
    /// The user can only access this field via avcodec_get_hw_config().
    pub hw_configs: *mut *mut AVCodecHWConfigInternal,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    assert_eq!(
        ::std::mem::size_of::<AVCodec>(),
        248usize,
        concat!("Size of: ", stringify!(AVCodec))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).capabilities as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_framerates as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_framerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).pix_fmts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(pix_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_samplerates as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).sample_fmts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).channel_layouts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).max_lowres as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(max_lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).priv_class as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).profiles as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).wrapper_name as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(wrapper_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).priv_data_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).next as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init_thread_copy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_thread_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).update_thread_context as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(update_thread_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).defaults as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init_static_data as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_static_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).encode_sub as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode_sub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).encode2 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).decode as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).close as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).send_frame as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).receive_packet as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).receive_frame as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).flush as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).caps_internal as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).bsfs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(bsfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).hw_configs as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(hw_configs)
        )
    );
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Retrieve supported hardware configurations for a codec.
    ///
    /// Values of index from zero to some maximum return the indexed configuration
    /// descriptor; all other values return NULL.  If the codec does not support
    /// any hardware configurations then it will always return NULL.
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: ::std::os::raw::c_int,
    ) -> *const AVCodecHWConfig;
}
/// @defgroup lavc_hwaccel AVHWAccel
///
/// @note  Nothing in this structure should be accessed by the user.  At some
///        point in future it will not be externally visible at all.
///
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWAccel {
    /// Name of the hardware accelerated codec.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    pub name: *const ::std::os::raw::c_char,
    /// Type of codec implemented by the hardware accelerator.
    ///
    /// See AVMEDIA_TYPE_xxx
    pub type_: AVMediaType,
    /// Codec implemented by the hardware accelerator.
    ///
    /// See AV_CODEC_ID_xxx
    pub id: AVCodecID,
    /// Supported pixel format.
    ///
    /// Only hardware accelerated formats are supported here.
    pub pix_fmt: AVPixelFormat,
    /// Hardware accelerated codec capabilities.
    /// see AV_HWACCEL_CODEC_CAP_*
    pub capabilities: ::std::os::raw::c_int,
    /// Allocate a custom buffer
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame)
            -> ::std::os::raw::c_int,
    >,
    /// Called at the beginning of each frame or field picture.
    ///
    /// Meaningful frame information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    ///
    /// Note that buf can be NULL along with buf_size set to 0.
    /// Otherwise, this means the whole frame is available at this point.
    ///
    /// @param avctx the codec context
    /// @param buf the frame data buffer base
    /// @param buf_size the size of the frame in bytes
    /// @return zero if successful, a negative value otherwise
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> ::std::os::raw::c_int,
    >,
    /// Callback for parameter data (SPS/PPS/VPS etc).
    ///
    /// Useful for hardware decoders which keep persistent state about the
    /// video parameters, and need to receive any changes to update that state.
    ///
    /// @param avctx the codec context
    /// @param type the nal unit type
    /// @param buf the nal unit data buffer
    /// @param buf_size the size of the nal unit in bytes
    /// @return zero if successful, a negative value otherwise
    pub decode_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            type_: ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for each slice.
    ///
    /// Meaningful slice information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    /// The only exception is XvMC, that works on MB level.
    ///
    /// @param avctx the codec context
    /// @param buf the slice data buffer base
    /// @param buf_size the size of the slice in bytes
    /// @return zero if successful, a negative value otherwise
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> ::std::os::raw::c_int,
    >,
    /// Called at the end of each frame or field picture.
    ///
    /// The whole picture is parsed at this point and can now be sent
    /// to the hardware accelerator. This function is mandatory.
    ///
    /// @param avctx the codec context
    /// @return zero if successful, a negative value otherwise
    pub end_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    /// Size of per-frame hardware accelerator private data.
    ///
    /// Private data is allocated with av_mallocz() before
    /// AVCodecContext.get_buffer() and deallocated after
    /// AVCodecContext.release_buffer().
    pub frame_priv_data_size: ::std::os::raw::c_int,
    /// Called for every Macroblock in a slice.
    ///
    /// XvMC uses it to replace the ff_mpv_reconstruct_mb().
    /// Instead of decoding to raw picture, MB parameters are
    /// stored in an array provided by the video driver.
    ///
    /// @param s the mpeg context
    pub decode_mb: ::std::option::Option<unsafe extern "C" fn(s: *mut MpegEncContext)>,
    /// Initialize the hwaccel private data.
    ///
    /// This will be called from ff_get_format(), after hwaccel and
    /// hwaccel_context are set and the hwaccel private data in AVCodecInternal
    /// is allocated.
    pub init: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    /// Uninitialize the hwaccel private data.
    ///
    /// This will be called from get_format() or avcodec_close(), after hwaccel
    /// and hwaccel_context are already uninitialized.
    pub uninit: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    /// Size of the private data to allocate in
    /// AVCodecInternal.hwaccel_priv_data.
    pub priv_data_size: ::std::os::raw::c_int,
    /// Internal hwaccel capabilities.
    pub caps_internal: ::std::os::raw::c_int,
    /// Fill the given hw_frames context with current codec parameters. Called
    /// from get_format. Refer to avcodec_get_hw_frames_parameters() for
    /// details.
    ///
    /// This CAN be called before AVHWAccel.init is called, and you must assume
    /// that avctx->hwaccel_priv_data is invalid.
    pub frame_params: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, hw_frames_ctx: *mut AVBufferRef)
            -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    assert_eq!(
        ::std::mem::size_of::<AVHWAccel>(),
        112usize,
        concat!("Size of: ", stringify!(AVHWAccel))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWAccel>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWAccel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).pix_fmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).capabilities as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).alloc_frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(alloc_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).start_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_slice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).end_frame as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).frame_priv_data_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_mb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_mb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).init as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).uninit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).priv_data_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).caps_internal as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).frame_params as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_params)
        )
    );
}
/// Picture data structure.
///
/// Up to four components can be stored into it, the last component is
/// alpha.
/// @deprecated use AVFrame or imgutils functions instead
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPicture {
    ///< pointers to the image data planes
    pub data: [*mut u8; 8usize],
    ///< number of bytes per line
    pub linesize: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_AVPicture() {
    assert_eq!(
        ::std::mem::size_of::<AVPicture>(),
        96usize,
        concat!("Size of: ", stringify!(AVPicture))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPicture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPicture>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPicture>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(linesize)
        )
    );
}
pub const AVSubtitleType_SUBTITLE_NONE: AVSubtitleType = 0;
///< A bitmap, pict will be set
pub const AVSubtitleType_SUBTITLE_BITMAP: AVSubtitleType = 1;
/// Plain text, the text field must be set by the decoder and is
/// authoritative. ass and pict fields may contain approximations.
pub const AVSubtitleType_SUBTITLE_TEXT: AVSubtitleType = 2;
/// Formatted text, the ass field must be set by the decoder and is
/// authoritative. pict and text fields may contain approximations.
pub const AVSubtitleType_SUBTITLE_ASS: AVSubtitleType = 3;
pub type AVSubtitleType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitleRect {
    ///< top left corner  of pict, undefined when pict is not set
    pub x: ::std::os::raw::c_int,
    ///< top left corner  of pict, undefined when pict is not set
    pub y: ::std::os::raw::c_int,
    ///< width            of pict, undefined when pict is not set
    pub w: ::std::os::raw::c_int,
    ///< height           of pict, undefined when pict is not set
    pub h: ::std::os::raw::c_int,
    ///< number of colors in pict, undefined when pict is not set
    pub nb_colors: ::std::os::raw::c_int,
    /// @deprecated unused
    pub pict: AVPicture,
    /// data+linesize for the bitmap of this subtitle.
    /// Can be set for text/ass as well once they are rendered.
    pub data: [*mut u8; 4usize],
    pub linesize: [::std::os::raw::c_int; 4usize],
    pub type_: AVSubtitleType,
    ///< 0 terminated plain UTF-8 text
    pub text: *mut ::std::os::raw::c_char,
    /// 0 terminated ASS/SSA compatible event line.
    /// The presentation of this is unaffected by the other values in this
    /// struct.
    pub ass: *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitleRect>(),
        200usize,
        concat!("Size of: ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitleRect>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).nb_colors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(nb_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).pict as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).linesize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).type_ as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).text as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).ass as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(ass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).flags as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    ///< Same as packet pts, in AV_TIME_BASE
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitle>(),
        32usize,
        concat!("Size of: ", stringify!(AVSubtitle))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitle>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).start_display_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(start_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).end_display_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(end_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).num_rects as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).rects as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).pts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(pts)
        )
    );
}
/// This struct describes the properties of an encoded stream.
///
/// sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
/// be allocated with avcodec_parameters_alloc() and freed with
/// avcodec_parameters_free().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParameters {
    /// General type of the encoded data.
    pub codec_type: AVMediaType,
    /// Specific type of the encoded data (the codec used).
    pub codec_id: AVCodecID,
    /// Additional information about the codec (corresponds to the AVI FOURCC).
    pub codec_tag: u32,
    /// Extra binary data needed for initializing the decoder, codec-dependent.
    ///
    /// Must be allocated with av_malloc() and will be freed by
    /// avcodec_parameters_free(). The allocated size of extradata must be at
    /// least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
    /// bytes zeroed.
    pub extradata: *mut u8,
    /// Size of the extradata content in bytes.
    pub extradata_size: ::std::os::raw::c_int,
    /// - video: the pixel format, the value corresponds to enum AVPixelFormat.
    /// - audio: the sample format, the value corresponds to enum AVSampleFormat.
    pub format: ::std::os::raw::c_int,
    /// The average bitrate of the encoded data (in bits per second).
    pub bit_rate: i64,
    /// The number of bits per sample in the codedwords.
    ///
    /// This is basically the bitrate per sample. It is mandatory for a bunch of
    /// formats to actually decode them. It's the number of bits for one sample in
    /// the actual coded bitstream.
    ///
    /// This could be for example 4 for ADPCM
    /// For PCM formats this matches bits_per_raw_sample
    /// Can be 0
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    /// This is the number of valid bits in each output sample. If the
    /// sample format has more bits, the least significant bits are additional
    /// padding bits, which are always 0. Use right shifts to reduce the sample
    /// to its actual size. For example, audio formats with 24 bit samples will
    /// have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
    /// To get the original sample use "(int32_t)sample >> 8"."
    ///
    /// For ADPCM this might be 12 or 16 or similar
    /// Can be 0
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    /// Codec-specific bitstream restrictions that the stream conforms to.
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    /// Video only. The dimensions of the video frame in pixels.
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    /// Video only. The aspect ratio (width / height) which a single pixel
    /// should have when displayed.
    ///
    /// When the aspect ratio is unknown / undefined, the numerator should be
    /// set to 0 (the denominator may have any value).
    pub sample_aspect_ratio: AVRational,
    /// Video only. The order of the fields in interlaced video.
    pub field_order: AVFieldOrder,
    /// Video only. Additional colorspace characteristics.
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /// Video only. Number of delayed frames.
    pub video_delay: ::std::os::raw::c_int,
    /// Audio only. The channel layout bitmask. May be 0 if the channel layout is
    /// unknown or unspecified, otherwise the number of bits set must be equal to
    /// the channels field.
    pub channel_layout: u64,
    /// Audio only. The number of audio channels.
    pub channels: ::std::os::raw::c_int,
    /// Audio only. The number of audio samples per second.
    pub sample_rate: ::std::os::raw::c_int,
    /// Audio only. The number of bytes per coded audio frame, required by some
    /// formats.
    ///
    /// Corresponds to nBlockAlign in WAVEFORMATEX.
    pub block_align: ::std::os::raw::c_int,
    /// Audio only. Audio frame size, if known. Required by some formats to be static.
    pub frame_size: ::std::os::raw::c_int,
    /// Audio only. The amount of padding (in samples) inserted by the encoder at
    /// the beginning of the audio. I.e. this number of leading decoded samples
    /// must be discarded by the caller to get the original audio without leading
    /// padding.
    pub initial_padding: ::std::os::raw::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    pub trailing_padding: ::std::os::raw::c_int,
    /// Audio only. Number of samples to skip after a discontinuity.
    pub seek_preroll: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParameters>(),
        144usize,
        concat!("Size of: ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).extradata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).extradata_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).format as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).bit_rate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_coded_sample as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_raw_sample as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).profile as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).level as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).sample_aspect_ratio as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).field_order as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_range as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).color_primaries as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_trc as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_space as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).chroma_location as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).video_delay as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(video_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).channel_layout as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).channels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).sample_rate as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).block_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).frame_size as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).initial_padding as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).trailing_padding as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).seek_preroll as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(seek_preroll)
        )
    );
}
extern "C" {
    /// Iterate over all registered codecs.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    ///               point to NULL to start the iteration.
    ///
    /// @return the next registered codec or NULL when the iteration is
    ///         finished
    pub fn av_codec_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodec;
}
extern "C" {
    /// If c is NULL, returns the first registered codec,
    /// if c is non-NULL, returns the next registered codec after c,
    /// or NULL if c is the last one.
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    /// Return the LIBAVCODEC_VERSION_INT constant.
    pub fn avcodec_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return the libavcodec build-time configuration.
    pub fn avcodec_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the libavcodec license.
    pub fn avcodec_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Register the codec codec and initialize libavcodec.
    ///
    /// @warning either this function or avcodec_register_all() must be called
    /// before any other libavcodec functions.
    ///
    /// @see avcodec_register_all()
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    /// Register all the codecs, parsers and bitstream filters which were enabled at
    /// configuration time. If you do not call this function you can select exactly
    /// which formats you want to support, by using the individual registration
    /// functions.
    ///
    /// @see avcodec_register
    /// @see av_register_codec_parser
    /// @see av_register_bitstream_filter
    pub fn avcodec_register_all();
}
extern "C" {
    /// Allocate an AVCodecContext and set its fields to default values. The
    /// resulting struct should be freed with avcodec_free_context().
    ///
    /// @param codec if non-NULL, allocate private data and initialize defaults
    ///              for the given codec. It is illegal to then call avcodec_open2()
    ///              with a different codec.
    ///              If NULL, then the codec-specific defaults won't be initialized,
    ///              which may result in suboptimal default settings (this is
    ///              important mainly for encoders, e.g. libx264).
    ///
    /// @return An AVCodecContext filled with default values or NULL on failure.
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    /// Free the codec context and everything associated with it and write NULL to
    /// the provided pointer.
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    /// @deprecated This function should not be used, as closing and opening a codec
    /// context multiple time is not supported. A new codec context should be
    /// allocated for each new use.
    pub fn avcodec_get_context_defaults3(
        s: *mut AVCodecContext,
        codec: *const AVCodec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the AVClass for AVCodecContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVFrame. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVSubtitleRect. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    /// Copy the settings of the source AVCodecContext into the destination
    /// AVCodecContext. The resulting destination codec context will be
    /// unopened, i.e. you are required to call avcodec_open2() before you
    /// can use this AVCodecContext to decode/encode video/audio data.
    ///
    /// @param dest target codec context, should be initialized with
    ///             avcodec_alloc_context3(NULL), but otherwise uninitialized
    /// @param src source codec context
    /// @return AVERROR() on error (e.g. memory allocation error), 0 on success
    ///
    /// @deprecated The semantics of this function are ill-defined and it should not
    /// be used. If you need to transfer the stream parameters from one codec context
    /// to another, use an intermediate AVCodecParameters instance and the
    /// avcodec_parameters_from_context() / avcodec_parameters_to_context()
    /// functions.
    pub fn avcodec_copy_context(
        dest: *mut AVCodecContext,
        src: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate a new AVCodecParameters and set its fields to default values
    /// (unknown/invalid/0). The returned struct must be freed with
    /// avcodec_parameters_free().
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    /// Free an AVCodecParameters instance and everything associated with it and
    /// write NULL to the supplied pointer.
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    /// Copy the contents of src to dst. Any allocated fields in dst are freed and
    /// replaced with newly allocated duplicates of the corresponding fields in src.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Fill the parameters struct based on the values from the supplied codec
    /// context. Any allocated fields in par are freed and replaced with duplicates
    /// of the corresponding fields in codec.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Fill the codec context based on the values from the supplied codec
    /// parameters. Any allocated fields in codec that have a corresponding field in
    /// par are freed and replaced with duplicates of the corresponding field in par.
    /// Fields in codec that do not have a counterpart in par are not touched.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize the AVCodecContext to use the given AVCodec. Prior to using this
    /// function the context has to be allocated with avcodec_alloc_context3().
    ///
    /// The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
    /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
    /// retrieving a codec.
    ///
    /// @warning This function is not thread safe!
    ///
    /// @note Always call this function before using decoding routines (such as
    /// @ref avcodec_receive_frame()).
    ///
    /// @code
    /// avcodec_register_all();
    /// av_dict_set(&opts, "b", "2.5M", 0);
    /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    /// if (!codec)
    ///     exit(1);
    ///
    /// context = avcodec_alloc_context3(codec);
    ///
    /// if (avcodec_open2(context, codec, opts) < 0)
    ///     exit(1);
    /// @endcode
    ///
    /// @param avctx The context to initialize.
    /// @param codec The codec to open this context for. If a non-NULL codec has been
    ///              previously passed to avcodec_alloc_context3() or
    ///              for this context, then this parameter MUST be either NULL or
    ///              equal to the previously passed codec.
    /// @param options A dictionary filled with AVCodecContext and codec-private options.
    ///                On return this object will be filled with options that were not found.
    ///
    /// @return zero on success, a negative value on error
    /// @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
    ///      av_dict_set(), av_opt_find().
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close a given AVCodecContext and free all the data associated with it
    /// (but not the AVCodecContext itself).
    ///
    /// Calling this function on an AVCodecContext that hasn't been opened will free
    /// the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
    /// codec. Subsequent calls will do nothing.
    ///
    /// @note Do not use this function. Use avcodec_free_context() to destroy a
    /// codec context (either open or closed). Opening and closing a codec context
    /// multiple times is not supported anymore -- use multiple codec contexts
    /// instead.
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Free all allocated data in the given subtitle struct.
    ///
    /// @param sub AVSubtitle to free.
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    /// Allocate an AVPacket and set its fields to default values.  The resulting
    /// struct must be freed using av_packet_free().
    ///
    /// @return An AVPacket filled with default values or NULL on failure.
    ///
    /// @note this only allocates the AVPacket itself, not the data buffers. Those
    /// must be allocated through other means such as av_new_packet.
    ///
    /// @see av_new_packet
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    /// Create a new packet that references the same data as src.
    ///
    /// This is a shortcut for av_packet_alloc()+av_packet_ref().
    ///
    /// @return newly created AVPacket on success, NULL on error.
    ///
    /// @see av_packet_alloc
    /// @see av_packet_ref
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    /// Free the packet, if the packet is reference counted, it will be
    /// unreferenced first.
    ///
    /// @param pkt packet to be freed. The pointer will be set to NULL.
    /// @note passing NULL is a no-op.
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    /// Initialize optional fields of a packet with default values.
    ///
    /// Note, this does not touch the data and size members, which have to be
    /// initialized separately.
    ///
    /// @param pkt packet
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate the payload of a packet and initialize its fields with
    /// default values.
    ///
    /// @param pkt packet
    /// @param size wanted payload size
    /// @return 0 if OK, AVERROR_xxx otherwise
    pub fn av_new_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reduce packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param size new size
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int);
}
extern "C" {
    /// Increase packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param grow_by number of bytes by which to increase the size of the packet
    pub fn av_grow_packet(
        pkt: *mut AVPacket,
        grow_by: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize a reference-counted packet from av_malloc()ed data.
    ///
    /// @param pkt packet to be initialized. This function will set the data, size,
    ///        buf and destruct fields, all others are left untouched.
    /// @param data Data allocated by av_malloc() to be used as packet data. If this
    ///        function returns successfully, the data is owned by the underlying AVBuffer.
    ///        The caller may not access the data through other means.
    /// @param size size of data in bytes, without the padding. I.e. the full buffer
    ///        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
    ///
    /// @return 0 on success, a negative AVERROR on error
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning This is a hack - the packet memory allocation stuff is broken. The
    /// packet is allocated if it was not really allocated.
    ///
    /// @deprecated Use av_packet_ref or av_packet_make_refcounted
    pub fn av_dup_packet(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy packet, including contents
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_ref
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy packet side data
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_copy_props
    pub fn av_copy_packet_side_data(
        dst: *mut AVPacket,
        src: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Free a packet.
    ///
    /// @deprecated Use av_packet_unref
    ///
    /// @param pkt packet to free
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate new information of a packet.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size side information size
    /// @return pointer to fresh allocated data or NULL otherwise
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Wrap an existing array as a packet side data.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param data the side data array. It must be allocated with the av_malloc()
    ///             family of functions. The ownership of the data is transferred to
    ///             pkt.
    /// @param size side information size
    /// @return a non-negative number on success, a negative AVERROR code on
    ///         failure. On failure, the packet is unchanged and the data remains
    ///         owned by the caller.
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Shrink the already allocated side data buffer
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size new side information size
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get side information from packet.
    ///
    /// @param pkt packet
    /// @param type desired side information type
    /// @param size pointer for side information size to store (optional)
    /// @return pointer to data if present or NULL otherwise
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Pack a dictionary for use in side_data.
    ///
    /// @param dict The dictionary to pack.
    /// @param size pointer to store the size of the returned data
    /// @return pointer to data if successful, NULL otherwise
    pub fn av_packet_pack_dictionary(
        dict: *mut AVDictionary,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Unpack a dictionary from side_data.
    ///
    /// @param data data from side_data
    /// @param size size of the data
    /// @param dict the metadata storage dictionary
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: ::std::os::raw::c_int,
        dict: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convenience function to free all the side data stored.
    /// All the other fields stay untouched.
    ///
    /// @param pkt packet
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    /// Setup a new reference to the data described by a given packet
    ///
    /// If src is reference-counted, setup dst as a new reference to the
    /// buffer in src. Otherwise allocate a new buffer in dst and copy the
    /// data from src into it.
    ///
    /// All the other fields are copied from src.
    ///
    /// @see av_packet_unref
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wipe the packet.
    ///
    /// Unreference the buffer referenced by the packet and reset the
    /// remaining packet fields to their default values.
    ///
    /// @param pkt The packet to be unreferenced.
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    /// Move every field in src to dst and reset src.
    ///
    /// @see av_packet_unref
    ///
    /// @param src Source packet, will be reset
    /// @param dst Destination packet
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    /// Copy only "properties" fields from src to dst.
    ///
    /// Properties for the purpose of this function are all the fields
    /// beside those related to the packet data (buf, data, size)
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success AVERROR on failure.
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Ensure the data described by a given packet is reference counted.
    ///
    /// @note This function does not ensure that the reference will be writable.
    ///       Use av_packet_make_writable instead for that purpose.
    ///
    /// @see av_packet_ref
    /// @see av_packet_make_writable
    ///
    /// @param pkt packet whose data should be made reference counted.
    ///
    /// @return 0 on success, a negative AVERROR on error. On failure, the
    ///         packet is unchanged.
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a writable reference for the data described by a given packet,
    /// avoiding data copy if possible.
    ///
    /// @param pkt Packet whose data should be made writable.
    ///
    /// @return 0 on success, a negative AVERROR on failure. On failure, the
    ///         packet is unchanged.
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convert valid timing fields (timestamps / durations) in a packet from one
    /// timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
    /// ignored.
    ///
    /// @param pkt packet on which the conversion will be performed
    /// @param tb_src source timebase, in which the timing fields in pkt are
    ///               expressed
    /// @param tb_dst destination timebase, to which the timing fields will be
    ///               converted
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
extern "C" {
    /// Find a registered decoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered decoder with the specified name.
    ///
    /// @param name name of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder_by_name(name: *const ::std::os::raw::c_char) -> *mut AVCodec;
}
extern "C" {
    /// The default callback for AVCodecContext.get_buffer2(). It is made public so
    /// it can be called by custom get_buffer2() implementations for decoders without
    /// AV_CODEC_CAP_DR1 set.
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you do not use any horizontal
    /// padding.
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you also ensure that all
    /// line sizes are a multiple of the respective linesize_align[i].
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        linesize_align: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Converts AVChromaLocation to swscale x/y chroma position.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Converts swscale x/y chroma position to AVChromaLocation.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_chroma_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
    ///
    /// Some decoders may support multiple frames in a single AVPacket. Such
    /// decoders would then just decode the first frame and the return value would be
    /// less than the packet size. In this case, avcodec_decode_audio4 has to be
    /// called again with an AVPacket containing the remaining data in order to
    /// decode the second frame, etc...  Even if no frames are returned, the packet
    /// needs to be fed to the decoder with remaining data until it is completely
    /// consumed or an error occurs.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning samples. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    ///          larger than the actual read bytes because some optimized bitstream
    ///          readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param      avctx the codec context
    /// @param[out] frame The AVFrame in which to store decoded audio samples.
    ///                   The decoder will allocate a buffer for the decoded frame by
    ///                   calling the AVCodecContext.get_buffer2() callback.
    ///                   When AVCodecContext.refcounted_frames is set to 1, the frame is
    ///                   reference counted and the returned reference belongs to the
    ///                   caller. The caller must release the frame using av_frame_unref()
    ///                   when the frame is no longer needed. The caller may safely write
    ///                   to the frame if av_frame_is_writable() returns 1.
    ///                   When AVCodecContext.refcounted_frames is set to 0, the returned
    ///                   reference belongs to the decoder and is valid only until the
    ///                   next call to this function or until closing or flushing the
    ///                   decoder. The caller may not write to it.
    /// @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
    ///                           non-zero. Note that this field being set to zero
    ///                           does not mean that an error has occurred. For
    ///                           decoders with AV_CODEC_CAP_DELAY set, no given decode
    ///                           call is guaranteed to produce a frame.
    /// @param[in]  avpkt The input AVPacket containing the input buffer.
    ///                   At least avpkt->data and avpkt->size should be set. Some
    ///                   decoders might also require additional fields to be set.
    /// @return A negative error code is returned if an error occurred during
    ///         decoding, otherwise the number of bytes consumed from the input
    ///         AVPacket is returned.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_audio4(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
        got_frame_ptr: *mut ::std::os::raw::c_int,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Decode the video frame of size avpkt->size from avpkt->data into picture.
    /// Some decoders may support multiple frames in a single AVPacket, such
    /// decoders would then just decode the first frame.
    ///
    /// @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
    /// the actual read bytes because some optimized bitstream readers read 32 or 64
    /// bits at once and could read over the end.
    ///
    /// @warning The end of the input buffer buf should be set to 0 to ensure that
    /// no overreading happens for damaged MPEG streams.
    ///
    /// @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
    /// between input and output, these need to be fed with avpkt->data=NULL,
    /// avpkt->size=0 at the end to return the remaining frames.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] picture The AVFrame in which the decoded video frame will be stored.
    ///             Use av_frame_alloc() to get an AVFrame. The codec will
    ///             allocate memory for the actual bitmap by calling the
    ///             AVCodecContext.get_buffer2() callback.
    ///             When AVCodecContext.refcounted_frames is set to 1, the frame is
    ///             reference counted and the returned reference belongs to the
    ///             caller. The caller must release the frame using av_frame_unref()
    ///             when the frame is no longer needed. The caller may safely write
    ///             to the frame if av_frame_is_writable() returns 1.
    ///             When AVCodecContext.refcounted_frames is set to 0, the returned
    ///             reference belongs to the decoder and is valid only until the
    ///             next call to this function or until closing or flushing the
    ///             decoder. The caller may not write to it.
    ///
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    ///            You can create such packet with av_init_packet() and by then setting
    ///            data and size, some decoders might in addition need other fields like
    ///            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
    ///            fields possible.
    /// @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
    /// @return On error a negative value is returned, otherwise the number of bytes
    /// used or zero if no frame could be decompressed.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_video2(
        avctx: *mut AVCodecContext,
        picture: *mut AVFrame,
        got_picture_ptr: *mut ::std::os::raw::c_int,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Decode a subtitle message.
    /// Return a negative value on error, otherwise return the number of bytes used.
    /// If no subtitle could be decompressed, got_sub_ptr is zero.
    /// Otherwise, the subtitle is stored in *sub.
    /// Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
    /// simplicity, because the performance difference is expect to be negligible
    /// and reusing a get_buffer written for video codecs would probably perform badly
    /// due to a potentially very different allocation pattern.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning subtitles. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
    ///                 must be freed with avsubtitle_free if *got_sub_ptr is set.
    /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut ::std::os::raw::c_int,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Supply raw packet data as input to a decoder.
    ///
    /// Internally, this call will copy relevant AVCodecContext fields, which can
    /// influence decoding per-packet, and apply them when the packet is actually
    /// decoded. (For example AVCodecContext.skip_frame, which might direct the
    /// decoder to drop the frame contained by the packet sent with this function.)
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    ///          larger than the actual read bytes because some optimized bitstream
    ///          readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
    ///          on the same AVCodecContext. It will return unexpected results now
    ///          or in future libavcodec versions.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    ///       before packets may be fed to the decoder.
    ///
    /// @param avctx codec context
    /// @param[in] avpkt The input AVPacket. Usually, this will be a single video
    ///                  frame, or several complete audio frames.
    ///                  Ownership of the packet remains with the caller, and the
    ///                  decoder will not write to the packet. The decoder may create
    ///                  a reference to the packet data (or copy it if the packet is
    ///                  not reference-counted).
    ///                  Unlike with older APIs, the packet is always fully consumed,
    ///                  and if it contains multiple frames (e.g. some audio codecs),
    ///                  will require you to call avcodec_receive_frame() multiple
    ///                  times afterwards before you can send a new packet.
    ///                  It can be NULL (or an AVPacket with data set to NULL and
    ///                  size set to 0); in this case, it is considered a flush
    ///                  packet, which signals the end of the stream. Sending the
    ///                  first flush packet will return success. Subsequent ones are
    ///                  unnecessary and will return AVERROR_EOF. If the decoder
    ///                  still has frames buffered, it will return them after sending
    ///                  a flush packet.
    ///
    /// @return 0 on success, otherwise negative error code:
    ///      AVERROR(EAGAIN):   input is not accepted in the current state - user
    ///                         must read output with avcodec_receive_frame() (once
    ///                         all output is read, the packet should be resent, and
    ///                         the call will not fail with EAGAIN).
    ///      AVERROR_EOF:       the decoder has been flushed, and no new packets can
    ///                         be sent to it (also returned if more than 1 flush
    ///                         packet is sent)
    ///      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
    ///      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    ///      other errors: legitimate decoding errors
    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return decoded output data from a decoder.
    ///
    /// @param avctx codec context
    /// @param frame This will be set to a reference-counted video or audio
    ///              frame (depending on the decoder type) allocated by the
    ///              decoder. Note that the function will always call
    ///              av_frame_unref(frame) before doing anything else.
    ///
    /// @return
    ///      0:                 success, a frame was returned
    ///      AVERROR(EAGAIN):   output is not available in this state - user must try
    ///                         to send new input
    ///      AVERROR_EOF:       the decoder has been fully flushed, and there will be
    ///                         no more output frames
    ///      AVERROR(EINVAL):   codec not opened, or it is an encoder
    ///      other negative values: legitimate decoding errors
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
    /// to retrieve buffered output packets.
    ///
    /// @param avctx     codec context
    /// @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
    ///                  Ownership of the frame remains with the caller, and the
    ///                  encoder will not write to the frame. The encoder may create
    ///                  a reference to the frame data (or copy it if the frame is
    ///                  not reference-counted).
    ///                  It can be NULL, in which case it is considered a flush
    ///                  packet.  This signals the end of the stream. If the encoder
    ///                  still has packets buffered, it will return them after this
    ///                  call. Once flushing mode has been entered, additional flush
    ///                  packets are ignored, and sending frames will return
    ///                  AVERROR_EOF.
    ///
    ///                  For audio:
    ///                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    ///                  can have any number of samples.
    ///                  If it is not set, frame->nb_samples must be equal to
    ///                  avctx->frame_size for all frames except the last.
    ///                  The final frame may be smaller than avctx->frame_size.
    /// @return 0 on success, otherwise negative error code:
    ///      AVERROR(EAGAIN):   input is not accepted in the current state - user
    ///                         must read output with avcodec_receive_packet() (once
    ///                         all output is read, the packet should be resent, and
    ///                         the call will not fail with EAGAIN).
    ///      AVERROR_EOF:       the encoder has been flushed, and no new frames can
    ///                         be sent to it
    ///      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
    ///                         decoder, or requires flush
    ///      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    ///      other errors: legitimate decoding errors
    pub fn avcodec_send_frame(
        avctx: *mut AVCodecContext,
        frame: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read encoded data from the encoder.
    ///
    /// @param avctx codec context
    /// @param avpkt This will be set to a reference-counted packet allocated by the
    ///              encoder. Note that the function will always call
    ///              av_frame_unref(frame) before doing anything else.
    /// @return 0 on success, otherwise negative error code:
    ///      AVERROR(EAGAIN):   output is not available in the current state - user
    ///                         must try to send input
    ///      AVERROR_EOF:       the encoder has been fully flushed, and there will be
    ///                         no more output packets
    ///      AVERROR(EINVAL):   codec not opened, or it is an encoder
    ///      other errors: legitimate decoding errors
    pub fn avcodec_receive_packet(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create and return a AVHWFramesContext with values adequate for hardware
    /// decoding. This is meant to get called from the get_format callback, and is
    /// a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
    /// This API is for decoding with certain hardware acceleration modes/APIs only.
    ///
    /// The returned AVHWFramesContext is not initialized. The caller must do this
    /// with av_hwframe_ctx_init().
    ///
    /// Calling this function is not a requirement, but makes it simpler to avoid
    /// codec or hardware API specific details when manually allocating frames.
    ///
    /// Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
    /// which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
    /// it unnecessary to call this function or having to care about
    /// AVHWFramesContext initialization at all.
    ///
    /// There are a number of requirements for calling this function:
    ///
    /// - It must be called from get_format with the same avctx parameter that was
    ///   passed to get_format. Calling it outside of get_format is not allowed, and
    ///   can trigger undefined behavior.
    /// - The function is not always supported (see description of return values).
    ///   Even if this function returns successfully, hwaccel initialization could
    ///   fail later. (The degree to which implementations check whether the stream
    ///   is actually supported varies. Some do this check only after the user's
    ///   get_format callback returns.)
    /// - The hw_pix_fmt must be one of the choices suggested by get_format. If the
    ///   user decides to use a AVHWFramesContext prepared with this API function,
    ///   the user must return the same hw_pix_fmt from get_format.
    /// - The device_ref passed to this function must support the given hw_pix_fmt.
    /// - After calling this API function, it is the user's responsibility to
    ///   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
    ///   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
    ///   before returning from get_format (this is implied by the normal
    ///   AVCodecContext.hw_frames_ctx API rules).
    /// - The AVHWFramesContext parameters may change every time time get_format is
    ///   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
    ///   you are inherently required to go through this process again on every
    ///   get_format call.
    /// - It is perfectly possible to call this function without actually using
    ///   the resulting AVHWFramesContext. One use-case might be trying to reuse a
    ///   previously initialized AVHWFramesContext, and calling this API function
    ///   only to test whether the required frame parameters have changed.
    /// - Fields that use dynamically allocated values of any kind must not be set
    ///   by the user unless setting them is explicitly allowed by the documentation.
    ///   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
    ///   the new free callback must call the potentially set previous free callback.
    ///   This API call may set any dynamically allocated fields, including the free
    ///   callback.
    ///
    /// The function will set at least the following fields on AVHWFramesContext
    /// (potentially more, depending on hwaccel API):
    ///
    /// - All fields set by av_hwframe_ctx_alloc().
    /// - Set the format field to hw_pix_fmt.
    /// - Set the sw_format field to the most suited and most versatile format. (An
    ///   implication is that this will prefer generic formats over opaque formats
    ///   with arbitrary restrictions, if possible.)
    /// - Set the width/height fields to the coded frame size, rounded up to the
    ///   API-specific minimum alignment.
    /// - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
    ///   field to the number of maximum reference surfaces possible with the codec,
    ///   plus 1 surface for the user to work (meaning the user can safely reference
    ///   at most 1 decoded surface at a time), plus additional buffering introduced
    ///   by frame threading. If the hwaccel does not require pre-allocation, the
    ///   field is left to 0, and the decoder will allocate new surfaces on demand
    ///   during decoding.
    /// - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
    ///   hardware API.
    ///
    /// Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
    /// with basic frame parameters set.
    ///
    /// The function is stateless, and does not change the AVCodecContext or the
    /// device_ref AVHWDeviceContext.
    ///
    /// @param avctx The context which is currently calling get_format, and which
    ///              implicitly contains all state needed for filling the returned
    ///              AVHWFramesContext properly.
    /// @param device_ref A reference to the AVHWDeviceContext describing the device
    ///                   which will be used by the hardware decoder.
    /// @param hw_pix_fmt The hwaccel format you are going to return from get_format.
    /// @param out_frames_ref On success, set to a reference to an _uninitialized_
    ///                       AVHWFramesContext, created from the given device_ref.
    ///                       Fields will be set to values required for decoding.
    ///                       Not changed if an error is returned.
    /// @return zero on success, a negative value on error. The following error codes
    ///         have special semantics:
    ///      AVERROR(ENOENT): the decoder does not support this functionality. Setup
    ///                       is always manual, or it is a decoder which does not
    ///                       support setting AVCodecContext.hw_frames_ctx at all,
    ///                       or it is a software format.
    ///      AVERROR(EINVAL): it is known that hardware decoding is not supported for
    ///                       this configuration, or the device_ref is not supported
    ///                       for the hwaccel referenced by hw_pix_fmt.
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_UNKNOWN: AVPictureStructure = 0;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_TOP_FIELD: AVPictureStructure = 1;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_BOTTOM_FIELD: AVPictureStructure = 2;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_FRAME: AVPictureStructure = 3;
/// @defgroup lavc_parsing Frame parsing
/// @{
pub type AVPictureStructure = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParserContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: ::std::os::raw::c_int,
    /// This field is used for proper frame duration computation in lavf.
    /// It signals, how much longer the frame duration of the current frame
    /// is compared to normal frame duration.
    ///
    /// frame_duration = (1 + repeat_pict) * time_base
    ///
    /// It is used by codecs like H.264 to display telecined material.
    pub repeat_pict: ::std::os::raw::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: ::std::os::raw::c_int,
    pub cur_frame_start_index: ::std::os::raw::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: ::std::os::raw::c_int,
    ///< byte offset from starting packet start
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    /// Set by parser to 1 for key frames and 0 for non-key frames.
    /// It is initialized to -1, so if the parser doesn't set this flag,
    /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
    /// will be used.
    pub key_frame: ::std::os::raw::c_int,
    /// @deprecated unused
    pub convergence_duration: i64,
    /// Synchronization point for start of timestamp generation.
    ///
    /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
    /// (default).
    ///
    /// For example, this corresponds to presence of H.264 buffering period
    /// SEI message.
    pub dts_sync_point: ::std::os::raw::c_int,
    /// Offset of the current timestamp against last timestamp sync point in
    /// units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain a valid timestamp offset.
    ///
    /// Note that the timestamp of sync point has usually a nonzero
    /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
    /// the next frame after timestamp sync point will be usually 1.
    ///
    /// For example, this corresponds to H.264 cpb_removal_delay.
    pub dts_ref_dts_delta: ::std::os::raw::c_int,
    /// Presentation delay of current frame in units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain valid non-negative timestamp delta (presentation time of a frame
    /// must not lie in the past).
    ///
    /// This delay represents the difference between decoding and presentation
    /// time of the frame.
    ///
    /// For example, this corresponds to H.264 dpb_output_delay.
    pub pts_dts_delta: ::std::os::raw::c_int,
    /// Position of the packet in file.
    ///
    /// Analogous to cur_frame_pts/dts
    pub cur_frame_pos: [i64; 4usize],
    /// Byte position of currently parsed frame in stream.
    pub pos: i64,
    /// Previous frame byte position.
    pub last_pos: i64,
    /// Duration of the current frame.
    /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
    /// For all other types, this is in units of AVCodecContext.time_base.
    pub duration: ::std::os::raw::c_int,
    pub field_order: AVFieldOrder,
    /// Indicate whether a picture is coded as a frame, top field or bottom field.
    ///
    /// For example, H.264 field_pic_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
    /// equal to 1 and bottom_field_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_TOP_FIELD.
    pub picture_structure: AVPictureStructure,
    /// Picture number incremented in presentation or output order.
    /// This field may be reinitialized at the first picture of a new sequence.
    ///
    /// For example, this corresponds to H.264 PicOrderCnt.
    pub output_picture_number: ::std::os::raw::c_int,
    /// Dimensions of the decoded video intended for presentation.
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    /// Dimensions of the coded video.
    pub coded_width: ::std::os::raw::c_int,
    pub coded_height: ::std::os::raw::c_int,
    /// The format of the coded data, corresponds to enum AVPixelFormat for video
    /// and for enum AVSampleFormat for audio.
    ///
    /// Note that a decoder can have considerable freedom in how exactly it
    /// decodes the data, so the format reported here might be different from the
    /// one returned by a decoder.
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParserContext>(),
        352usize,
        concat!("Size of: ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).priv_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).parser as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).frame_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).cur_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).next_frame_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(next_frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pict_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).repeat_pict as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).dts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_dts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).fetch_timestamp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(fetch_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_start_index as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_offset as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pts as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_dts as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).flags as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).offset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_end as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).key_frame as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).convergence_duration as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(convergence_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_sync_point as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_sync_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_ref_dts_delta as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_ref_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).pts_dts_delta as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pos as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pos as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pos as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).duration as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).field_order as *const _ as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).picture_structure as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).output_picture_number as *const _
                as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(output_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).width as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).height as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_width as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_height as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).format as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParser {
    pub codec_ids: [::std::os::raw::c_int; 5usize],
    pub priv_data_size: ::std::os::raw::c_int,
    pub parser_init: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecParserContext) -> ::std::os::raw::c_int,
    >,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub next: *mut AVCodecParser,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParser>(),
        64usize,
        concat!("Size of: ", stringify!(AVCodecParser))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParser>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).codec_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).priv_data_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_parse as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).split as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    /// Iterate over all registered codec parsers.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    ///               point to NULL to start the iteration.
    ///
    /// @return the next registered codec parser or NULL when the iteration is
    ///         finished
    pub fn av_parser_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: ::std::os::raw::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    /// Parse a packet.
    ///
    /// @param s             parser context.
    /// @param avctx         codec context.
    /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
    /// @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
    /// @param buf           input buffer.
    /// @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
    ///size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
    ///To signal EOF, this should be 0 (so that the last frame
    ///can be output).
    /// @param pts           input presentation timestamp.
    /// @param dts           input decoding timestamp.
    /// @param pos           input byte position in stream.
    /// @return the number of bytes of the input bitstream used.
    ///
    /// Example:
    /// @code
    ///   while(in_len){
    ///       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
    ///                                        in_data, in_len,
    ///                                        pts, dts, pos);
    ///       in_data += len;
    ///       in_len  -= len;
    ///
    ///       if(size)
    ///          decode_frame(data, size);
    ///   }
    /// @endcode
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
    /// @deprecated use AVBitStreamFilter
    pub fn av_parser_change(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        keyframe: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    /// Find a registered encoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered encoder with the specified name.
    ///
    /// @param name name of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder_by_name(name: *const ::std::os::raw::c_char) -> *mut AVCodec;
}
extern "C" {
    /// Encode a frame of audio.
    ///
    /// Takes input samples from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay, split, and combine input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    ///                  The user can supply an output buffer by setting
    ///                  avpkt->data and avpkt->size prior to calling the
    ///                  function, but if the size of the user-provided data is not
    ///                  large enough, encoding will fail. If avpkt->data and
    ///                  avpkt->size are set, avpkt->destruct must also be set. All
    ///                  other AVPacket fields will be reset by the encoder using
    ///                  av_init_packet(). If avpkt->data is NULL, the encoder will
    ///                  allocate it. The encoder will set avpkt->size to the size
    ///                  of the output packet.
    ///
    ///                  If this function fails or produces no output, avpkt will be
    ///                  freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw audio data to be encoded.
    ///                  May be NULL when flushing an encoder that has the
    ///                  AV_CODEC_CAP_DELAY capability set.
    ///                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    ///                  can have any number of samples.
    ///                  If it is not set, frame->nb_samples must be equal to
    ///                  avctx->frame_size for all frames except the last.
    ///                  The final frame may be smaller than avctx->frame_size.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    ///                            output packet is non-empty, and to 0 if it is
    ///                            empty. If the function returns an error, the
    ///                            packet can be assumed to be invalid, and the
    ///                            value of got_packet_ptr is undefined and should
    ///                            not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_audio2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Encode a frame of video.
    ///
    /// Takes input raw video data from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay and reorder input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    ///                  The user can supply an output buffer by setting
    ///                  avpkt->data and avpkt->size prior to calling the
    ///                  function, but if the size of the user-provided data is not
    ///                  large enough, encoding will fail. All other AVPacket fields
    ///                  will be reset by the encoder using av_init_packet(). If
    ///                  avpkt->data is NULL, the encoder will allocate it.
    ///                  The encoder will set avpkt->size to the size of the
    ///                  output packet. The returned data (if any) belongs to the
    ///                  caller, he is responsible for freeing it.
    ///
    ///                  If this function fails or produces no output, avpkt will be
    ///                  freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw video data to be encoded.
    ///                  May be NULL when flushing an encoder that has the
    ///                  AV_CODEC_CAP_DELAY capability set.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    ///                            output packet is non-empty, and to 0 if it is
    ///                            empty. If the function returns an error, the
    ///                            packet can be assumed to be invalid, and the
    ///                            value of got_packet_ptr is undefined and should
    ///                            not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_video2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: ::std::os::raw::c_int,
        sub: *const AVSubtitle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_alloc(
        picture: *mut AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    /// @deprecated use av_image_fill_arrays() instead.
    pub fn avpicture_fill(
        picture: *mut AVPicture,
        ptr: *const u8,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated use av_image_copy_to_buffer() instead.
    pub fn avpicture_layout(
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_uchar,
        dest_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated use av_image_get_buffer_size() instead.
    pub fn avpicture_get_size(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated av_image_copy() instead.
    pub fn av_picture_copy(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_crop(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        top_band: ::std::os::raw::c_int,
        left_band: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_pad(
        dst: *mut AVPicture,
        src: *const AVPicture,
        height: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        padtop: ::std::os::raw::c_int,
        padbottom: ::std::os::raw::c_int,
        padleft: ::std::os::raw::c_int,
        padright: ::std::os::raw::c_int,
        color: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated Use av_pix_fmt_get_chroma_sub_sample
    pub fn avcodec_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut ::std::os::raw::c_int,
        v_shift: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Return a value representing the fourCC code associated to the
    /// pixel format pix_fmt, or 0 if no associated fourCC code can be
    /// found.
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// @deprecated see av_get_pix_fmt_loss()
    pub fn avcodec_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find the best pixel format to convert to given a certain source pixel
    /// format.  When converting from one pixel format to another, information loss
    /// may occur.  For example, when converting from RGB24 to GRAY, the color
    /// information will be lost. Similarly, other losses occur when converting from
    /// some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
    /// the given pixel formats should be used to suffer the least amount of loss.
    /// The pixel formats from which it chooses one, are determined by the
    /// pix_fmt_list parameter.
    ///
    ///
    /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
    /// @return The best pixel format to convert to or -1 if none was found.
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    /// @deprecated see av_find_best_pix_fmt_of_2()
    pub fn avcodec_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    /// Put a string representing the codec tag codec_tag in buf.
    ///
    /// @param buf       buffer to place codec tag in
    /// @param buf_size size in bytes of buf
    /// @param codec_tag codec tag to assign
    /// @return the length of the string that would have been generated if
    /// enough space had been available, excluding the trailing null
    ///
    /// @deprecated see av_fourcc_make_string() and av_fourcc2str().
    pub fn av_get_codec_tag_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        codec_tag: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn avcodec_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        enc: *mut AVCodecContext,
        encode: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec the codec that is searched for the given profile
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    pub fn av_get_profile_name(
        codec: *const AVCodec,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec_id the ID of the codec to which the requested profile belongs
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    ///
    /// @note unlike av_get_profile_name(), which searches a list of profiles
    ///       supported by a specific decoder or encoder implementation, this
    ///       function searches the list of profiles from the AVCodecDescriptor
    pub fn avcodec_profile_name(
        codec_id: AVCodecID,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(c2: *mut AVCodecContext, arg2: *mut ::std::os::raw::c_void)
                -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Fill AVFrame audio data and linesize pointers.
    ///
    /// The buffer buf must be a preallocated buffer with a size big enough
    /// to contain the specified samples amount. The filled AVFrame data
    /// pointers will point to this buffer.
    ///
    /// AVFrame extended_data channel pointers are allocated if necessary for
    /// planar audio.
    ///
    /// @param frame       the AVFrame
    ///                    frame->nb_samples must be set prior to calling the
    ///                    function. This function fills in frame->data,
    ///                    frame->extended_data, frame->linesize[0].
    /// @param nb_channels channel count
    /// @param sample_fmt  sample format
    /// @param buf         buffer to use for frame data
    /// @param buf_size    size of buffer
    /// @param align       plane size sample alignment (0 = default)
    /// @return            >=0 on success, negative error code on failure
    /// @todo return the size in bytes required to store the samples in
    /// case of success, at the next libavutil bump
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset the internal decoder state / flush internal buffers. Should be called
    /// e.g. when seeking or when switching to a different stream.
    ///
    /// @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),
    /// this invalidates the frames previously returned from the decoder. When
    /// refcounted frames are used, the decoder just releases any references it might
    /// keep internally, but the caller's reference remains valid.
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    /// Return codec bits per sample.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the PCM codec associated with a sample format.
    /// @param be  endianness, 0 for little, 1 for big,
    ///            -1 (or anything else) for native
    /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: ::std::os::raw::c_int) -> AVCodecID;
}
extern "C" {
    /// Return codec bits per sample.
    /// Only return non-zero if the bits per sample is exactly correct, not an
    /// approximation.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return audio frame duration.
    ///
    /// @param avctx        codec context
    /// @param frame_bytes  size of the frame, or 0 if unknown
    /// @return             frame duration, in samples, if known. 0 if not able to
    ///                     determine.
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function is the same as av_get_audio_frame_duration(), except it works
    /// with AVCodecParameters instead of an AVCodecContext.
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub filter: *const AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    /// Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
    /// Not for access by library users.
    pub args: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilterContext() {
    assert_eq!(
        ::std::mem::size_of::<AVBitStreamFilterContext>(),
        40usize,
        concat!("Size of: ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBitStreamFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBitStreamFilterContext>())).priv_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).parser as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
/// The bitstream filter state.
///
/// This struct must be allocated with av_bsf_alloc() and freed with
/// av_bsf_free().
///
/// The fields in the struct will only be changed (by the caller or by the
/// filter) as described in their documentation, and are to be considered
/// immutable otherwise.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFContext {
    /// A class for logging and AVOptions
    pub av_class: *const AVClass,
    /// The bitstream filter this context is an instance of.
    pub filter: *const AVBitStreamFilter,
    /// Opaque libavcodec internal data. Must not be touched by the caller in any
    /// way.
    pub internal: *mut AVBSFInternal,
    /// Opaque filter-specific private data. If filter->priv_class is non-NULL,
    /// this is an AVOptions-enabled struct.
    pub priv_data: *mut ::std::os::raw::c_void,
    /// Parameters of the input stream. This field is allocated in
    /// av_bsf_alloc(), it needs to be filled by the caller before
    /// av_bsf_init().
    pub par_in: *mut AVCodecParameters,
    /// Parameters of the output stream. This field is allocated in
    /// av_bsf_alloc(), it is set by the filter in av_bsf_init().
    pub par_out: *mut AVCodecParameters,
    /// The timebase used for the timestamps of the input packets. Set by the
    /// caller before av_bsf_init().
    pub time_base_in: AVRational,
    /// The timebase used for the timestamps of the output packets. Set by the
    /// filter in av_bsf_init().
    pub time_base_out: AVRational,
}
#[test]
fn bindgen_test_layout_AVBSFContext() {
    assert_eq!(
        ::std::mem::size_of::<AVBSFContext>(),
        64usize,
        concat!("Size of: ", stringify!(AVBSFContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBSFContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBSFContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).internal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).par_in as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).par_out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).time_base_in as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).time_base_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_out)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilter {
    pub name: *const ::std::os::raw::c_char,
    /// A list of codec ids supported by the filter, terminated by
    /// AV_CODEC_ID_NONE.
    /// May be NULL, in that case the bitstream filter works with any codec id.
    pub codec_ids: *const AVCodecID,
    /// A class for the private data, used to declare bitstream filter private
    /// AVOptions. This field is NULL for bitstream filters that do not declare
    /// any options.
    ///
    /// If this field is non-NULL, the first member of the filter private data
    /// must be a pointer to AVClass, which will be set by libavcodec generic
    /// code to this class.
    pub priv_class: *const AVClass,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: ::std::os::raw::c_int,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext) -> ::std::os::raw::c_int,
    >,
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
    pub flush: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilter() {
    assert_eq!(
        ::std::mem::size_of::<AVBitStreamFilter>(),
        64usize,
        concat!("Size of: ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBitStreamFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).codec_ids as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).priv_class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBitStreamFilter>())).priv_data_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).filter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).flush as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(flush)
        )
    );
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use the new bitstream filtering API (using AVBSFContext).
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()
    /// from the new bitstream filtering API (using AVBSFContext).
    pub fn av_bitstream_filter_init(
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVBitStreamFilterContext;
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the
    /// new bitstream filtering API (using AVBSFContext).
    pub fn av_bitstream_filter_filter(
        bsfc: *mut AVBitStreamFilterContext,
        avctx: *mut AVCodecContext,
        args: *const ::std::os::raw::c_char,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        keyframe: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_free() from the new bitstream filtering API (using
    /// AVBSFContext).
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using
    /// AVBSFContext).
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter) -> *const AVBitStreamFilter;
}
extern "C" {
    /// @return a bitstream filter with the specified name or NULL if no such
    ///         bitstream filter exists.
    pub fn av_bsf_get_by_name(name: *const ::std::os::raw::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Iterate over all registered bitstream filters.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    ///               point to NULL to start the iteration.
    ///
    /// @return the next registered bitstream filter or NULL when the iteration is
    ///         finished
    pub fn av_bsf_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_next(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Allocate a context for a given bitstream filter. The caller must fill in the
    /// context parameters as described in the documentation and then call
    /// av_bsf_init() before sending any data to the filter.
    ///
    /// @param filter the filter for which to allocate an instance.
    /// @param ctx a pointer into which the pointer to the newly-allocated context
    ///            will be written. It must be freed with av_bsf_free() after the
    ///            filtering is done.
    ///
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Prepare the filter for use, after all the parameters and options have been
    /// set.
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a packet for filtering.
    ///
    /// After sending each packet, the filter must be completely drained by calling
    /// av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
    /// AVERROR_EOF.
    ///
    /// @param pkt the packet to filter. The bitstream filter will take ownership of
    /// the packet and reset the contents of pkt. pkt is not touched if an error occurs.
    /// This parameter may be NULL, which signals the end of the stream (i.e. no more
    /// packets will be sent). That will cause the filter to output any packets it
    /// may have buffered internally.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve a filtered packet.
    ///
    /// @param[out] pkt this struct will be filled with the contents of the filtered
    ///                 packet. It is owned by the caller and must be freed using
    ///                 av_packet_unref() when it is no longer needed.
    ///                 This parameter should be "clean" (i.e. freshly allocated
    ///                 with av_packet_alloc() or unreffed with av_packet_unref())
    ///                 when this function is called. If this function returns
    ///                 successfully, the contents of pkt will be completely
    ///                 overwritten by the returned data. On failure, pkt is not
    ///                 touched.
    ///
    /// @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
    /// filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
    /// will be no further output from the filter. Another negative AVERROR value if
    /// an error occurs.
    ///
    /// @note one input packet may result in several output packets, so after sending
    /// a packet with av_bsf_send_packet(), this function needs to be called
    /// repeatedly until it stops returning 0. It is also possible for a filter to
    /// output fewer packets than were sent to it, so this function may return
    /// AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
    pub fn av_bsf_receive_packet(
        ctx: *mut AVBSFContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset the internal bitstream filter state / flush internal buffers.
    pub fn av_bsf_flush(ctx: *mut AVBSFContext);
}
extern "C" {
    /// Free a bitstream filter context and everything associated with it; write NULL
    /// into the supplied pointer.
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    /// Get the AVClass for AVBSFContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate empty list of bitstream filters.
    /// The list must be later freed by av_bsf_list_free()
    /// or finalized by av_bsf_list_finalize().
    ///
    /// @return Pointer to @ref AVBSFList on success, NULL in case of failure
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    /// Free list of bitstream filters.
    ///
    /// @param lst Pointer to pointer returned by av_bsf_list_alloc()
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    /// Append bitstream filter to the list of bitstream filters.
    ///
    /// @param lst List to append to
    /// @param bsf Filter context to be appended
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Construct new bitstream filter context given it's name and options
    /// and append it to the list of bitstream filters.
    ///
    /// @param lst      List to append to
    /// @param bsf_name Name of the bitstream filter
    /// @param options  Options for the bitstream filter, can be set to NULL
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Finalize list of bitstream filters.
    ///
    /// This function will transform @ref AVBSFList to single @ref AVBSFContext,
    /// so the whole chain of bitstream filters can be treated as single filter
    /// freshly allocated by av_bsf_alloc().
    /// If the call is successful, @ref AVBSFList structure is freed and lst
    /// will be set to NULL. In case of failure, caller is responsible for
    /// freeing the structure by av_bsf_list_free()
    ///
    /// @param      lst Filter list structure to be transformed
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    ///                 representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Parse string describing list of bitstream filters and create single
    /// @ref AVBSFContext describing the whole chain of bitstream filters.
    /// Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
    /// allocated by av_bsf_alloc().
    ///
    /// @param      str String describing chain of bitstream filters in format
    ///                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    ///                 representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_parse_str(
        str: *const ::std::os::raw::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get null/pass-through bitstream filter.
    ///
    /// @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
    ///
    /// @return
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Same behaviour av_fast_malloc but the buffer has additional
    /// AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
    ///
    /// In addition the whole buffer will initially and after resizes
    /// be 0-initialized so that no uninitialized data will ever appear.
    pub fn av_fast_padded_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Same behaviour av_fast_padded_malloc except that buffer will always
    /// be 0-initialized after call.
    pub fn av_fast_padded_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Encode extradata length to a buffer. Used by xiph codecs.
    ///
    /// @param s buffer to write to; must be at least (v/255+1) bytes long
    /// @param v size of extradata in bytes
    /// @return number of bytes written to the buffer.
    pub fn av_xiphlacing(
        s: *mut ::std::os::raw::c_uchar,
        v: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Register the hardware accelerator hwaccel.
    ///
    /// @deprecated  This function doesn't do anything.
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    /// If hwaccel is NULL, returns the first registered hardware accelerator,
    /// if hwaccel is non-NULL, returns the next registered hardware accelerator
    /// after hwaccel, or NULL if hwaccel is the last one.
    ///
    /// @deprecated  AVHWaccel structures contain no user-serviceable parts, so
    ///              this function should not be used.
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
///< Create a mutex
pub const AVLockOp_AV_LOCK_CREATE: AVLockOp = 0;
///< Lock the mutex
pub const AVLockOp_AV_LOCK_OBTAIN: AVLockOp = 1;
///< Unlock the mutex
pub const AVLockOp_AV_LOCK_RELEASE: AVLockOp = 2;
///< Free mutex resources
pub const AVLockOp_AV_LOCK_DESTROY: AVLockOp = 3;
/// Lock operation used by lockmgr
///
/// @deprecated Deprecated together with av_lockmgr_register().
pub type AVLockOp = i32;
extern "C" {
    /// Register a user provided lock manager supporting the operations
    /// specified by AVLockOp. The "mutex" argument to the function points
    /// to a (void *) where the lockmgr should store/get a pointer to a user
    /// allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
    /// value left by the last call for all other ops. If the lock manager is
    /// unable to perform the op then it should leave the mutex in the same
    /// state as when it was called and return a non-zero value. However,
    /// when called with AV_LOCK_DESTROY the mutex will always be assumed to
    /// have been successfully destroyed. If av_lockmgr_register succeeds
    /// it will return a non-negative value, if it fails it will return a
    /// negative value and destroy all mutex and unregister all callbacks.
    /// av_lockmgr_register is not thread-safe, it must be called from a
    /// single thread before any calls which make use of locking are used.
    ///
    /// @param cb User defined callback. av_lockmgr_register invokes calls
    ///           to this callback and the previously registered callback.
    ///           The callback will be used to create more than one mutex
    ///           each of which must be backed by its own underlying locking
    ///           mechanism (i.e. do not use a single static object to
    ///           implement your lock manager). If cb is set to NULL the
    ///           lockmgr will be unregistered.
    ///
    /// @deprecated This function does nothing, and always returns 0. Be sure to
    ///             build with thread support to get basic thread safety.
    pub fn av_lockmgr_register(
        cb: ::std::option::Option<
            unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void, op: AVLockOp)
                -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the type of the given codec.
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    /// Get the name of a codec.
    /// @return  a static string identifying the codec; never NULL
    pub fn avcodec_get_name(id: AVCodecID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @return a positive value if s is open (i.e. avcodec_open2() was called on it
    /// with no corresponding avcodec_close()), 0 otherwise.
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is an encoder, zero otherwise
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is a decoder, zero otherwise
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @return descriptor for given codec ID or NULL if no descriptor exists.
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Iterate over all codec descriptors known to libavcodec.
    ///
    /// @param prev previous descriptor. NULL to get the first descriptor.
    ///
    /// @return next descriptor or NULL after the last descriptor
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    /// @return codec descriptor with the given name or NULL if no such descriptor
    ///         exists.
    pub fn avcodec_descriptor_get_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Allocate a CPB properties structure and initialize its fields to default
    /// values.
    ///
    /// @param size if non-NULL, the size of the allocated struct will be written
    ///             here. This is useful for embedding it in side data.
    ///
    /// @return the newly allocated struct or NULL on failure
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOption {
    pub _address: u8,
}
/// Array of pointers to hardware configurations supported by the codec,
/// or NULL if no hardware supported.  The array is terminated by a NULL
/// pointer.
///
/// The user can only access this field via avcodec_get_hw_config().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfigInternal {
    pub _address: u8,
}
